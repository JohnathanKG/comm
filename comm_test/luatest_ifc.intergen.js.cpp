
//@file  javascript interface dispatcher generated by intergen v7
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

#include "ifc/other.js.h"
#include "ifc/main.js.h"

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface other of class other_cls
//
////////////////////////////////////////////////////////////////////////////////

namespace ns {
namespace js {

////////////////////////////////////////////////////////////////////////////////
class other_js_dispatcher
    : public ::js::interface_wrapper_base<ns::other>
{
    static void _js_release_callback(const v8::WeakCallbackInfo<other_js_dispatcher>& data)
    {
        other_js_dispatcher* ifc = data.GetParameter();
        ifc->_object.Reset();
        ifc->release_refcount();
    }

protected:

    backend intergen_backend() const override { return backend::js; }

public:

    v8::Handle<v8::Object> create_interface_object( v8::Handle<v8::Context> context, bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& script, const coid::token& file_name );

    COIDNEWDELETE(other_js_dispatcher);

    other_js_dispatcher()
    {}

    explicit other_js_dispatcher( ns::other* orig ) {
        _base.create(orig);
        _vtable = _base->vtable();

        _host = _base->host<policy_intrusive_base>();
    }

    explicit other_js_dispatcher(policy_intrusive_base* host) {
        set_host(host, this, 0);
    }

    ~other_js_dispatcher()
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::HandleScope handle_scope__(iso);

        if (!_object.IsEmpty()) {
            _object.Get(iso)->SetInternalField(0, v8::Null(iso));
        }

        _object.Reset();
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

    static iref<other_js_dispatcher> create( const ::js::script_handle& scriptpath, const coid::charstr& str, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_create0(const v8::ARGUMENTS& args);

    static void v8rebind_events( const v8::ARGUMENTS& args );
    static void v8current_global( const v8::ARGUMENTS& args );

    // --- method wrappers ---

    static void v8_get_str0( const v8::ARGUMENTS& args );
    static void v8_set_str1( const v8::ARGUMENTS& args );
    static void v8_some_fun12( const v8::ARGUMENTS& args );
};

////////////////////////////////////////////////////////////////////////////////
void other_js_dispatcher::v8_get_str0( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "other.get_str";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::other>* ifc = static_cast<::js::interface_wrapper_base<ns::other>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "other.get_str";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in

        //invoke
        const coid::charstr& _rval_ = R_->get_str();

        //stream out
        v8::Handle<v8::Value> r__;
        static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
        r__ = read_to_v8(_rval_);

        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void other_js_dispatcher::v8_set_str1( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "other.set_str";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::other>* ifc = static_cast<::js::interface_wrapper_base<ns::other>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "other.set_str";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<coid::token>::value, "missing metastream operator for 'coid::token'");

        threadcached<coid::token> new_str;
        write_from_v8(args[0], new_str);

        //invoke
        R_->set_str(new_str);

        //stream out
        v8::Handle<v8::Object> r__;

        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void other_js_dispatcher::v8_some_fun12( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 2 || args.Length() > 2) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "other.some_fun1";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::other>* ifc = static_cast<::js::interface_wrapper_base<ns::other>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "other.some_fun1";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");

        threadcached<int> a;
        write_from_v8(args[0], a);

        threadcached<iref<ns::other>> b;
        write_from_v8(args[1], b);

        //invoke
        int c;

        R_->some_fun1(a, b, &c);

        //stream out
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__->Set(ctx, v8::symbol("a", iso), read_to_v8(a));
 
        r__->Set(ctx, v8::symbol("b", iso), ::js::wrap_object(b.get(), ifc->context(iso)));
 
        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__->Set(ctx, v8::symbol("c", iso), read_to_v8(c));
 
        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}


////////////////////////////////////////////////////////////////////////////////
void other_js_dispatcher::v8rebind_events( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    return (void)args.GetReturnValue().Set(v8::Undefined(iso));
}

////////////////////////////////////////////////////////////////////////////////
void other_js_dispatcher::v8current_global( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::other_js_dispatcher* ifc = static_cast<ns::js::other_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    args.GetReturnValue().Set(ifc->context(iso)->Global()->GetPrototype());
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> other_js_dispatcher::create_interface_object( v8::Handle<v8::Context> context, bool make_weak )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = v8::ObjectTemplate::New(iso);

        ot->Set(v8::Symbol::GetToStringTag(iso), v8::string_utf8("ns::other"));
        ot->SetInternalFieldCount(2);    //ptr and class hash id

        ot->Set(v8::symbol("get_str", iso), v8::FunctionTemplate::New(iso, &v8_get_str0));
        ot->Set(v8::symbol("set_str", iso), v8::FunctionTemplate::New(iso, &v8_set_str1));
        ot->Set(v8::symbol("some_fun1", iso), v8::FunctionTemplate::New(iso, &v8_some_fun12));

        ot->Set(v8::symbol("$log", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::js_log));
        ot->Set(v8::symbol("$query_interface", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::js_query_interface));
        ot->Set(v8::symbol("$rebind_events", iso), v8::FunctionTemplate::New(iso, &v8rebind_events));
        ot->Set(v8::symbol("$ctx", iso), v8::FunctionTemplate::New(iso, &v8current_global));

        _objtempl.Reset(iso, ot);
    }

    v8::Context::Scope ctxscope(context);
    v8::Local<v8::Object> obj = _objtempl.Get(iso)->NewInstance(context).ToLocalChecked();

    v8::Handle<v8::External> map_ptr = v8::External::New(iso, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = v8::External::New(iso, (void*)ints(4089385363));
    obj->SetInternalField(1, hash_ptr);

    if (make_weak) {
        _object.Reset(iso, obj);

        _object.SetWeak(this, _js_release_callback, v8::WeakCallbackType::kParameter);
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> other_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    return ::js::script_handle::load_script(script, fname, ::js::rethrow_in_cxx);
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<other_js_dispatcher> other_js_dispatcher::create( const ::js::script_handle& script, const coid::charstr& str, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<other_js_dispatcher> ifc = ns::other::create(new other_js_dispatcher, str);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = v8::Context::New(iso);
            v8::Context::Scope context_scope(context);
            ::js::script_handle::register_global_context_methods(context->Global(), iso);
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = handle_scope__.Escape(context);

    v8::Context::Scope context_scope(context);

    if (!extctx && !script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());
    }
    else {
        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));
    }

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> other_js_dispatcher::v8creator_create0(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+1 || args.Length() > 1+1) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "create";
        v8::queue_js_exception(iso, &v8::Exception::Error, tmp);
        return v8::Undefined(iso);
    }

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();

    //ns::js::other_js_dispatcher* ifc = static_cast<ns::js::other_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");
    threadcached<coid::charstr> str;
    write_from_v8(args[1+0], str);

    //invoke
    iref<other_js_dispatcher> nifc = ns::other::create(new other_js_dispatcher, str);

    //stream out
    v8::Handle<v8::Value> r__ = nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso));

    return handle_scope__.Escape(r__);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> create_wrapper_other( ::ns::other* orig, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if (!orig)
        return v8::Null(iso);

    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    v8::Context::Scope context_scope(context);
    v8::EscapableHandleScope scope(iso);

    iref<ns::js::other_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if (orig->intergen_backend() == intergen_interface::backend::js)
        obj = static_cast<other_js_dispatcher*>(orig)->_object.Get(iso);

    if (obj.IsEmpty()) {
        // create interface object
        ifc.create(new ns::js::other_js_dispatcher(static_cast<::ns::other*>(orig)));

        obj = ifc->create_interface_object(context, true);
    }

    return scope.Escape(obj);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<ns::js::other_js_dispatcher> create_maker_other( policy_intrusive_base* host, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = context.IsEmpty() ? v8::Isolate::GetCurrent() : context->GetIsolate();
    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    // check that the orig points to an object
    if (!host)
        return 0;

    v8::Context::Scope context_scope(context);
    v8::HandleScope scope(iso);

    // create interface object
    iref<ns::js::other_js_dispatcher> ifc;

    ifc.create(new ns::js::other_js_dispatcher(host));

    ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_other( bool on )
{
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "ns::other.create@creator.js",
        on ? (void*)&other_js_dispatcher::create : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "ns::js::other.create",
        on ? (void*)&other_js_dispatcher::v8creator_create0 : nullptr);

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "ns::other@wrapper.js",
        on ? (void*)&create_wrapper_other : nullptr);

    //js interface creator from host
    interface_register::register_interface_creator(
        "ns::other@maker.js",
        on ? (void*)&create_maker_other : nullptr);
}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) other_autoregger = new ifc_autoregger(&register_binders_for_other);


void* force_register_other() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_other);
    return autoregger.get();
}

} //namespace js
} //namespace ns

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface main of class main_cls
//
////////////////////////////////////////////////////////////////////////////////

namespace ns {
namespace js {

////////////////////////////////////////////////////////////////////////////////
class main_js_dispatcher
    : public ::js::interface_wrapper_base<ns::main>
{
    mutable v8::Persistent<v8::Function> _events[4];
    mutable bool _bound_events;

    static void _js_release_callback(const v8::WeakCallbackInfo<main_js_dispatcher>& data)
    {
        main_js_dispatcher* ifc = data.GetParameter();
        ifc->_object.Reset();
        ifc->release_refcount();
    }

protected:

    backend intergen_backend() const override { return backend::js; }

public:

    v8::Handle<v8::Object> create_interface_object( v8::Handle<v8::Context> context, bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& script, const coid::token& file_name );
    void bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref ) const;

    COIDNEWDELETE(main_js_dispatcher);

    main_js_dispatcher() : _bound_events(false)
    {}

    explicit main_js_dispatcher( ns::main* orig ) : _bound_events(false) {
        _base.create(orig);
        _vtable = _base->vtable();

        _host = _base->host<policy_intrusive_base>();
    }

    explicit main_js_dispatcher(policy_intrusive_base* host) : _bound_events(false) {
        set_host(host, this, 0);
    }

    ~main_js_dispatcher()
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::HandleScope handle_scope__(iso);

        for (int i=0; i<4; ++i) {
            _events[i].Reset();
        }

        if (!_object.IsEmpty()) {
            _object.Get(iso)->SetInternalField(0, v8::Null(iso));
        }

        _object.Reset();
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

    static iref<main_js_dispatcher> create( const ::js::script_handle& scriptpath, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_create0(const v8::ARGUMENTS& args);

    static iref<main_js_dispatcher> create_special( const ::js::script_handle& scriptpath, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_create_special1(const v8::ARGUMENTS& args);

    static iref<main_js_dispatcher> create_wp( const ::js::script_handle& scriptpath, int a, int& b, int& c, int d, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_create_wp2(const v8::ARGUMENTS& args);

    static void v8rebind_events( const v8::ARGUMENTS& args );
    static void v8current_global( const v8::ARGUMENTS& args );

    // --- method wrappers ---

    static void v8_some_get0( const v8::ARGUMENTS& args );
    static void v8_get_a1( const v8::ARGUMENTS& args );
    static void v8_set_a2( const v8::ARGUMENTS& args );
    static void v8_fun13( const v8::ARGUMENTS& args );
    static void v8_fun24( const v8::ARGUMENTS& args );

    // --- interface events ---

    virtual void evt1( int a, int* b, iref<ns::other>& d ) override;
    virtual coid::charstr evt2( int a, int* b, ns1::dummy& c, iref<ns::other>& d, iref<ns::other> e ) override;
    virtual iref<ns::other> evt3( const coid::token& msg ) override;
    virtual iref<ns::main> evt4( int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e = -1 ) override;

    virtual bool is_bound_evt1() override { return is_event_bound(0); }
    virtual bool is_bound_evt2() override { return is_event_bound(1); }
    virtual bool is_bound_evt3() override { return is_event_bound(2); }
    virtual bool is_bound_evt4() override { return is_event_bound(3); }

    virtual void force_bind_script_events() {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::HandleScope handle_scope__(iso);
        v8::TryCatch js_trycatch(iso);

        bind_events(context(iso), true, v8::Local<v8::Value>());
    }

private:
    bool is_event_bound( int id )
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();

        if (!_bound_events) {
            v8::HandleScope handle_scope__(iso);
            v8::TryCatch js_trycatch(iso);

            bind_events(context(iso), false, v8::Undefined(iso));
        }

        return !_events[id].IsEmpty() && !_events[id].Get(iso)->IsUndefined();
    }

    //event wrappers for event invocation from js
    static void v8_evback_evt10(const v8::ARGUMENTS& args);
    static void v8_evback_evt21(const v8::ARGUMENTS& args);
    static void v8_evback_evt32(const v8::ARGUMENTS& args);
    static void v8_evback_evt43(const v8::ARGUMENTS& args);
};

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_some_get0( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.some_get";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::main>* ifc = static_cast<::js::interface_wrapper_base<ns::main>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "main.some_get";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in

        //invoke
        coid::charstr a;

        iref<ns::other> _rval_ = R_->some_get(a);

        //stream out
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$ret", iso), ::js::wrap_object(_rval_.get(), ifc->context(iso)));

        static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
        r__->Set(ctx, v8::symbol("a", iso), read_to_v8(a));
 
        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_get_a1( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 0 || args.Length() > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.get_a";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::main>* ifc = static_cast<::js::interface_wrapper_base<ns::main>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "main.get_a";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in

        //invoke
        int _rval_ = R_->get_a();

        //stream out
        v8::Handle<v8::Value> r__;
        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__ = read_to_v8(_rval_);

        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_set_a2( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1 || args.Length() > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.set_a";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::main>* ifc = static_cast<::js::interface_wrapper_base<ns::main>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "main.set_a";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");

        threadcached<int> a;
        write_from_v8(args[0], a);

        //invoke
        R_->set_a(a);

        //stream out
        v8::Handle<v8::Object> r__;

        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_fun13( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 4 || args.Length() > 4) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.fun1";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::main>* ifc = static_cast<::js::interface_wrapper_base<ns::main>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "main.fun1";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        static_assert(CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'");
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator for 'float'");
        static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");

        threadcached<int> a;
        write_from_v8(args[0], a);

        threadcached<ns1::dummy> b;
        write_from_v8(args[1], b);

        threadcached<float> c;
        write_from_v8(args[2], c);

        threadcached<coid::charstr> g;
        write_from_v8(args[3], g);

        //invoke
        ns1::dummy d;

        int e;

        iref<ns::other> f;

        R_->fun1(a, b, &c, d, &e, f, g);

        //stream out
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        static_assert( CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'" );
        r__->Set(ctx, v8::symbol("d", iso), read_to_v8(d));
 
        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__->Set(ctx, v8::symbol("e", iso), read_to_v8(e));
 
        r__->Set(ctx, v8::symbol("f", iso), ::js::wrap_object(f.get(), ifc->context(iso)));
 
        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_fun24( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 2 || args.Length() > 2) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.fun2";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<ns::main>* ifc = static_cast<::js::interface_wrapper_base<ns::main>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "main.fun2";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");

        threadcached<int> a;
        write_from_v8(args[0], a);

        threadcached<iref<ns::other>> b;
        write_from_v8(args[1], b);

        //invoke
        int c;

        iref<ns::other> d;

        coid::charstr _rval_ = R_->fun2(a, b, c, d);

        //stream out
        static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$ret", iso), read_to_v8(_rval_));

        static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
        r__->Set(ctx, v8::symbol("c", iso), read_to_v8(c));
 
        r__->Set(ctx, v8::symbol("d", iso), ::js::wrap_object(d.get(), ifc->context(iso)));
 
        args.GetReturnValue().Set(r__);

    } catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::evt1( int a, int* b, iref<ns::other>& d )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    v8::HandleScope handle_scope__(iso);
    v8::Handle<v8::Context> ctx__ = context(iso);
    v8::Context::Scope context_scope__(ctx__);
    v8::TryCatch js_trycatch__(iso);

    bind_events(ctx__, false, v8::Undefined(iso));
    auto ev__ = _events[0].Get(iso);

    if (_events[0].IsEmpty() || ev__->IsUndefined())
        throw coid::exception("handler not implemented");

// prepare in arguments
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    v8::Handle<v8::Value> __inargs[] = {
        to_v8<int>::read(a)
    };

//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        ctx__,
        _object.Get(iso),
        1, __inargs).ToLocalChecked();


    if (js_trycatch__.HasCaught())
        ::js::script_handle::throw_exception_from_js_error(js_trycatch__, "ns::js::main.evt1");
// gather results

    if (!r__->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> obj__ = r__->ToObject(ctx__).ToLocalChecked();

    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    if (b)
        write_from_v8(obj__->Get(ctx__, v8::symbol("b", iso)).ToLocalChecked(), *b);

    write_from_v8(obj__->Get(ctx__, v8::symbol("d", iso)).ToLocalChecked(), d);

}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_evback_evt10( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch js_trycatch(iso);

    ifc->bind_events(ctx, false, v8::Undefined(iso));
    auto ev__ = ifc->_events[0].Get(iso);

    if (ifc->_events[0].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "evt1";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Value> largs[1];
    int nargs = args.Length();
    if (nargs > 1)
        nargs = 1;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];

    v8::Local<v8::Value> r__ = ev__->Call(
        ctx,
        ifc->_object.Get(iso),
        nargs, largs).ToLocalChecked();

    args.GetReturnValue().Set(r__);
}

////////////////////////////////////////////////////////////////////////////////
coid::charstr main_js_dispatcher::evt2( int a, int* b, ns1::dummy& c, iref<ns::other>& d, iref<ns::other> e )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    v8::HandleScope handle_scope__(iso);
    v8::Handle<v8::Context> ctx__ = context(iso);
    v8::Context::Scope context_scope__(ctx__);
    v8::TryCatch js_trycatch__(iso);

    bind_events(ctx__, false, v8::Undefined(iso));
    auto ev__ = _events[1].Get(iso);

    if (_events[1].IsEmpty() || ev__->IsUndefined())
        throw coid::exception("handler not implemented");

// prepare in arguments
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    static_assert( CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'" );
    v8::Handle<v8::Value> __inargs[] = {
        to_v8<int>::read(a),
        to_v8<ns1::dummy>::read(c),
        to_v8<iref<ns::other>>::read(e)
    };

//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        ctx__,
        _object.Get(iso),
        3, __inargs).ToLocalChecked();


    if (js_trycatch__.HasCaught())
        ::js::script_handle::throw_exception_from_js_error(js_trycatch__, "ns::js::main.evt2");
// gather results

    if (!r__->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> obj__ = r__->ToObject(ctx__).ToLocalChecked();

    //return value
    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
    threadcached<coid::charstr> _rval_;
    write_from_v8(obj__->Get(ctx__, v8::symbol("$ret", iso)).ToLocalChecked(), _rval_);

    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    if (b)
        write_from_v8(obj__->Get(ctx__, v8::symbol("b", iso)).ToLocalChecked(), *b);

    static_assert( CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'" );
    write_from_v8(obj__->Get(ctx__, v8::symbol("c", iso)).ToLocalChecked(), c);

    write_from_v8(obj__->Get(ctx__, v8::symbol("d", iso)).ToLocalChecked(), d);

    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_evback_evt21( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch js_trycatch(iso);

    ifc->bind_events(ctx, false, v8::Undefined(iso));
    auto ev__ = ifc->_events[1].Get(iso);

    if (ifc->_events[1].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "evt2";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Value> largs[3];
    int nargs = args.Length();
    if (nargs > 3)
        nargs = 3;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];

    v8::Local<v8::Value> r__ = ev__->Call(
        ctx,
        ifc->_object.Get(iso),
        nargs, largs).ToLocalChecked();

    args.GetReturnValue().Set(r__);
}

////////////////////////////////////////////////////////////////////////////////
iref<ns::other> main_js_dispatcher::evt3( const coid::token& msg )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    v8::HandleScope handle_scope__(iso);
    v8::Handle<v8::Context> ctx__ = context(iso);
    v8::Context::Scope context_scope__(ctx__);
    v8::TryCatch js_trycatch__(iso);

    bind_events(ctx__, false, v8::Undefined(iso));
    auto ev__ = _events[2].Get(iso);

    if (_events[2].IsEmpty() || ev__->IsUndefined())
        throw coid::exception("handler not implemented");

// prepare in arguments
    static_assert( CHECK::meta_operator_exists<coid::token>::value, "missing metastream operator for 'coid::token'" );
    v8::Handle<v8::Value> __inargs[] = {
        to_v8<coid::token>::read(msg)
    };

//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        ctx__,
        _object.Get(iso),
        1, __inargs).ToLocalChecked();


    if (js_trycatch__.HasCaught())
        ::js::script_handle::throw_exception_from_js_error(js_trycatch__, "ns::js::main.evt3");
// gather results

    iref<ns::other> _rval_;
    write_from_v8(r__, _rval_);
    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_evback_evt32( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch js_trycatch(iso);

    ifc->bind_events(ctx, false, v8::Undefined(iso));
    auto ev__ = ifc->_events[2].Get(iso);

    if (ifc->_events[2].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "evt3";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Value> largs[1];
    int nargs = args.Length();
    if (nargs > 1)
        nargs = 1;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];

    v8::Local<v8::Value> r__ = ev__->Call(
        ctx,
        ifc->_object.Get(iso),
        nargs, largs).ToLocalChecked();

    args.GetReturnValue().Set(r__);
}

////////////////////////////////////////////////////////////////////////////////
iref<ns::main> main_js_dispatcher::evt4( int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    v8::HandleScope handle_scope__(iso);
    v8::Handle<v8::Context> ctx__ = context(iso);
    v8::Context::Scope context_scope__(ctx__);
    v8::TryCatch js_trycatch__(iso);

    bind_events(ctx__, false, v8::Undefined(iso));
    auto ev__ = _events[3].Get(iso);

    if (_events[3].IsEmpty() || ev__->IsUndefined())
        throw coid::exception("handler not implemented");

// prepare in arguments
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    v8::Handle<v8::Value> __inargs[] = {
        to_v8<int>::read(a),
        to_v8<iref<ns::other>>::read(b),
        to_v8<int>::read(e)
    };

//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        ctx__,
        _object.Get(iso),
        3, __inargs).ToLocalChecked();


    if (js_trycatch__.HasCaught())
        ::js::script_handle::throw_exception_from_js_error(js_trycatch__, "ns::js::main.evt4");
// gather results

    if (!r__->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> obj__ = r__->ToObject(ctx__).ToLocalChecked();

    //return value
    iref<ns::main> _rval_;
    write_from_v8(r__, _rval_);

    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    write_from_v8(obj__->Get(ctx__, v8::symbol("c", iso)).ToLocalChecked(), c);

    write_from_v8(obj__->Get(ctx__, v8::symbol("d", iso)).ToLocalChecked(), d);

    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8_evback_evt43( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch js_trycatch(iso);

    ifc->bind_events(ctx, false, v8::Undefined(iso));
    auto ev__ = ifc->_events[3].Get(iso);

    if (ifc->_events[3].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "evt4";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Value> largs[3];
    int nargs = args.Length();
    if (nargs > 3)
        nargs = 3;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];

    v8::Local<v8::Value> r__ = ev__->Call(
        ctx,
        ifc->_object.Get(iso),
        nargs, largs).ToLocalChecked();

    args.GetReturnValue().Set(r__);
}


////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8rebind_events( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if (ifc) {
        v8::Local<v8::Value> val;
        if (args.Length() > 0)
            val = args[0];
        ifc->bind_events(ifc->context(iso), true, val);
    }

    return (void)args.GetReturnValue().Set(v8::Undefined(iso));
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::v8current_global( const v8::ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    args.GetReturnValue().Set(ifc->context(iso)->Global()->GetPrototype());
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> main_js_dispatcher::create_interface_object( v8::Handle<v8::Context> context, bool make_weak )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = v8::ObjectTemplate::New(iso);

        ot->Set(v8::Symbol::GetToStringTag(iso), v8::string_utf8("ns::main"));
        ot->SetInternalFieldCount(2);    //ptr and class hash id

        ot->Set(v8::symbol("some_get", iso), v8::FunctionTemplate::New(iso, &v8_some_get0));
        ot->Set(v8::symbol("get_a", iso), v8::FunctionTemplate::New(iso, &v8_get_a1));
        ot->Set(v8::symbol("set_a", iso), v8::FunctionTemplate::New(iso, &v8_set_a2));
        ot->Set(v8::symbol("fun1", iso), v8::FunctionTemplate::New(iso, &v8_fun13));
        ot->Set(v8::symbol("fun2", iso), v8::FunctionTemplate::New(iso, &v8_fun24));

        ot->Set(v8::symbol("$log", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::js_log));
        ot->Set(v8::symbol("$query_interface", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::js_query_interface));
        ot->Set(v8::symbol("$rebind_events", iso), v8::FunctionTemplate::New(iso, &v8rebind_events));
        ot->Set(v8::symbol("$ctx", iso), v8::FunctionTemplate::New(iso, &v8current_global));

        //event wrappers for event invocation from outside js
        ot->Set(v8::symbol("evt1", iso), v8::FunctionTemplate::New(iso, &v8_evback_evt10));
        ot->Set(v8::symbol("evt2", iso), v8::FunctionTemplate::New(iso, &v8_evback_evt21));
        ot->Set(v8::symbol("evt3", iso), v8::FunctionTemplate::New(iso, &v8_evback_evt32));
        ot->Set(v8::symbol("evt4", iso), v8::FunctionTemplate::New(iso, &v8_evback_evt43));

        _objtempl.Reset(iso, ot);
    }

    v8::Context::Scope ctxscope(context);
    v8::Local<v8::Object> obj = _objtempl.Get(iso)->NewInstance(context).ToLocalChecked();

    v8::Handle<v8::External> map_ptr = v8::External::New(iso, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = v8::External::New(iso, (void*)ints(3187450219));
    obj->SetInternalField(1, hash_ptr);

    if (make_weak) {
        _object.Reset(iso, obj);

        _object.SetWeak(this, _js_release_callback, v8::WeakCallbackType::kParameter);
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> main_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    return ::js::script_handle::load_script(script, fname, ::js::rethrow_in_cxx);
}

////////////////////////////////////////////////////////////////////////////////
void main_js_dispatcher::bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref ) const
{
    if (!force && _bound_events)
        return;

    //check if the context is from a html window & wait for loaded state
    bool final_state = true;
    uint nf = context->GetNumberOfEmbedderDataFields();
    const uint* cs = nf > 3 ? (const uint*)context->GetAlignedPointerFromEmbedderData(3) : 0;
    if (cs && (*cs & ~1ULL) == 0xBB07F010ULL) {
        if ((*cs & 1) == 0)
            final_state = false;
    }

    v8::Isolate* iso = context->GetIsolate();

    static token names[] = {
        "evt1"_T,
        "evt2"_T,
        "evt3"_T,
        "evt4"_T,
    };

    v8::HandleScope handle_scope__(iso);
    v8::Context::Scope context_scope__(context);
    v8::TryCatch js_trycatch(iso);
    v8::Local<v8::Object> global;

    bool clear = false;
    if (ref.IsEmpty() || ref->IsUndefined())
        global = context->Global();
    else if (ref->IsNull())
        clear = true;
    else
        global = ref->ToObject(context).ToLocalChecked();

    for (int i=0; i<4; ++i)
    {
        _events[i].Reset();

        if (clear)
            continue;

        v8::Local<v8::Value> var = v8::get_value(global, names[i], context);
        if (var->IsUndefined())
            continue;

        v8::Local<v8::Function> foo = v8::Local<v8::Function>::Cast(var);
        bool failed = js_trycatch.HasCaught() || foo->IsUndefined();

        if (!failed)
             _events[i].Reset(iso, foo);
    }

    if (final_state)
        _bound_events = true;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<main_js_dispatcher> main_js_dispatcher::create( const ::js::script_handle& script, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<main_js_dispatcher> ifc = ns::main::create(new main_js_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = v8::Context::New(iso);
            v8::Context::Scope context_scope(context);
            ::js::script_handle::register_global_context_methods(context->Global(), iso);
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = handle_scope__.Escape(context);

    v8::Context::Scope context_scope(context);

    if (!extctx && !script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());
    }
    else {
        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));
    }

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> main_js_dispatcher::v8creator_create0(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+0 || args.Length() > 1+0) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "create";
        v8::queue_js_exception(iso, &v8::Exception::Error, tmp);
        return v8::Undefined(iso);
    }

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();

    //ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    //invoke
    iref<main_js_dispatcher> nifc = ns::main::create(new main_js_dispatcher);

    //stream out
    v8::Handle<v8::Value> r__ = nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso));

    return handle_scope__.Escape(r__);
}

////////////////////////////////////////////////////////////////////////////////
iref<main_js_dispatcher> main_js_dispatcher::create_special( const ::js::script_handle& script, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<main_js_dispatcher> ifc = ns::main::create_special(new main_js_dispatcher, a, b, c, d, e);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = v8::Context::New(iso);
            v8::Context::Scope context_scope(context);
            ::js::script_handle::register_global_context_methods(context->Global(), iso);
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = handle_scope__.Escape(context);

    v8::Context::Scope context_scope(context);

    if (!extctx && !script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());
    }
    else {
        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));
    }

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> main_js_dispatcher::v8creator_create_special1(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+2 || args.Length() > 1+3) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "create_special";
        v8::queue_js_exception(iso, &v8::Exception::Error, tmp);
        return v8::Undefined(iso);
    }

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();

    //ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    threadcached<int> a;
    write_from_v8(args[1+0], a);

    threadcached<iref<ns::other>> b;
    write_from_v8(args[1+1], b);

    threadcached<int> e;
    if (1 + 2 < args.Length())
        write_from_v8(args[1+2], e);
    else
        e = -1;

    //invoke
    int c;

    iref<ns::other> d;

    iref<main_js_dispatcher> nifc = ns::main::create_special(new main_js_dispatcher, a, b, c, d, e);

    //stream out
    v8::Handle<v8::Object> r__ = v8::Object::New(iso);
    r__->Set(ctx, v8::symbol("$ret", iso), nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso)));

    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    r__->Set(ctx, v8::symbol("c", iso), read_to_v8(c));

    r__->Set(ctx, v8::symbol("d", iso), read_to_v8(d));

    return handle_scope__.Escape(r__);
}

////////////////////////////////////////////////////////////////////////////////
iref<main_js_dispatcher> main_js_dispatcher::create_wp( const ::js::script_handle& script, int a, int& b, int& c, int d, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<main_js_dispatcher> ifc = ns::main::create_wp(new main_js_dispatcher, a, b, c, d);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = v8::Context::New(iso);
            v8::Context::Scope context_scope(context);
            ::js::script_handle::register_global_context_methods(context->Global(), iso);
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = handle_scope__.Escape(context);

    v8::Context::Scope context_scope(context);

    if (!extctx && !script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());
    }
    else {
        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));
    }

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> main_js_dispatcher::v8creator_create_wp2(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+2 || args.Length() > 1+3) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "create_wp";
        v8::queue_js_exception(iso, &v8::Exception::Error, tmp);
        return v8::Undefined(iso);
    }

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();

    //ns::js::main_js_dispatcher* ifc = static_cast<ns::js::main_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    threadcached<int> a;
    write_from_v8(args[1+0], a);

    threadcached<int> b;
    write_from_v8(args[1+1], b);

    threadcached<int> d;
    if (1 + 2 < args.Length())
        write_from_v8(args[1+2], d);
    else
        d = -1;

    //invoke
    int c;

    iref<main_js_dispatcher> nifc = ns::main::create_wp(new main_js_dispatcher, a, b, c, d);

    //stream out
    v8::Handle<v8::Object> r__ = v8::Object::New(iso);
    r__->Set(ctx, v8::symbol("$ret", iso), nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso)));

    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    r__->Set(ctx, v8::symbol("b", iso), read_to_v8(b));

    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
    r__->Set(ctx, v8::symbol("c", iso), read_to_v8(c));

    return handle_scope__.Escape(r__);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> create_wrapper_main( ::ns::main* orig, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if (!orig)
        return v8::Null(iso);

    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    v8::Context::Scope context_scope(context);
    v8::EscapableHandleScope scope(iso);

    iref<ns::js::main_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if (orig->intergen_backend() == intergen_interface::backend::js)
        obj = static_cast<main_js_dispatcher*>(orig)->_object.Get(iso);

    if (obj.IsEmpty()) {
        // create interface object
        ifc.create(new ns::js::main_js_dispatcher(static_cast<::ns::main*>(orig)));

        obj = ifc->create_interface_object(context, true);
    }

    return scope.Escape(obj);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<ns::js::main_js_dispatcher> create_maker_main( policy_intrusive_base* host, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = context.IsEmpty() ? v8::Isolate::GetCurrent() : context->GetIsolate();
    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    // check that the orig points to an object
    if (!host)
        return 0;

    v8::Context::Scope context_scope(context);
    v8::HandleScope scope(iso);

    // create interface object
    iref<ns::js::main_js_dispatcher> ifc;

    ifc.create(new ns::js::main_js_dispatcher(host));

    ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_main( bool on )
{
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "ns::main.create@creator.js",
        on ? (void*)&main_js_dispatcher::create : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "ns::js::main.create",
        on ? (void*)&main_js_dispatcher::v8creator_create0 : nullptr);
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "ns::main.create_special@creator.js",
        on ? (void*)&main_js_dispatcher::create_special : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "ns::js::main.create_special",
        on ? (void*)&main_js_dispatcher::v8creator_create_special1 : nullptr);
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "ns::main.create_wp@creator.js",
        on ? (void*)&main_js_dispatcher::create_wp : nullptr);

    //creator from script
    interface_register::register_interface_creator(
        "ns::js::main.create_wp",
        on ? (void*)&main_js_dispatcher::v8creator_create_wp2 : nullptr);

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "ns::main@wrapper.js",
        on ? (void*)&create_wrapper_main : nullptr);

    //js interface creator from host
    interface_register::register_interface_creator(
        "ns::main@maker.js",
        on ? (void*)&create_maker_main : nullptr);
}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) main_autoregger = new ifc_autoregger(&register_binders_for_main);


void* force_register_main() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_main);
    return autoregger.get();
}

} //namespace js
} //namespace ns

