
//@file  javascript interface dispatcher generated by intergen v5
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

#include "ifc/thingface.js.h"

using namespace coid;

#ifdef V8_MAJOR_VERSION

#define UNDEFINED           v8::Local<v8::Value>()
#define NULLv8(iso)         v8::Null(iso)

#define HANDLE_SCOPE(iso,hs)    v8::HandleScope hs(iso)
#define ESCAPABLE_SCOPE(iso,hs) v8::EscapableHandleScope hs(iso)
#define ESCAPE(hs,h)        hs.Escape(h)

#define ARGUMENTS           v8::FunctionCallbackInfo<v8::Value>
#define CBK_RET             void
#define CBK_UNDEFINED       

#define NEWTYPE(iso,t)      v8::t::New(iso)
#define NEWTYPE2(iso,t,a)   v8::t::New(iso, a)
#define PERSISTENT(iso,o,n) o.Reset(iso, n)
#define RESET(o)            o.Reset()
#define LOCAL(iso,o)        o.Get(iso)

#else

#define UNDEFINED           v8::Undefined()
#define NULLv8(iso)         v8::Null()

#define HANDLE_SCOPE(iso,hs)    v8::HandleScope hs
#define ESCAPABLE_SCOPE(iso,hs) v8::HandleScope hs
#define ESCAPE(hs,h)        hs.Close(h)

#define ARGUMENTS           v8::Arguments
#define CBK_RET             v8::Handle<v8::Value>
#define CBK_UNDEFINED       v8::Undefined()

#define NEWTYPE(iso,t)      v8::t::New()
#define NEWTYPE2(iso,t,a)   v8::t::New(a)
#define PERSISTENT(iso,o,n) o = o.New(iso,n)
#define RESET(o)            o.Dispose(); o.Clear()
#define LOCAL(iso,o)        o

#endif


#ifdef V8_MAJOR_VERSION

static void _js_release_callback(const v8::WeakCallbackData<v8::Object, void*>& data)
{
    void* p = data.GetParameter();
    if(p)
        static_cast<intergen_interface*>(p)->release_refcount();
}

#else

static void _js_release_callback(v8::Persistent<v8::Value> object, void* p)
{
    if(p)
        static_cast<intergen_interface*>(p)->release_refcount();
    //object.Dispose();
}

#endif

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface thingface of class thing
//
////////////////////////////////////////////////////////////////////////////////

namespace ifc1 {
namespace ifc2 {
namespace js {

////////////////////////////////////////////////////////////////////////////////
class thingface_js_dispatcher
    : public ::js::interface_wrapper_base<ifc1::ifc2::thingface>
{
    v8::Persistent<v8::Function> _events[1];
    //v8::Persistent<v8::Object> _eventobj;
    bool _bound_events;

protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_JS; }

public:

    v8::Handle<v8::Object> create_interface_object( bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& scriptfile, const coid::token& file_name );
    void bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref );

    COIDNEWDELETE("ifc1::ifc2::thingface_js_dispatcher");

    thingface_js_dispatcher() : _bound_events(false)
    {}

    thingface_js_dispatcher( v8::Handle<v8::Context> context, ifc1::ifc2::thingface* orig ) : _bound_events(false) {
        _base.create(orig);
        _vtable = _base->vtable();
        PERSISTENT(v8::Isolate::GetCurrent(), _context, context);

		_host = _base->host<policy_intrusive_base>();
    }

    ~thingface_js_dispatcher() {
        //RESET(_eventobj);

        for(int i=0; i<1; ++i) {
            RESET(_events[i]);
        }

        //if(!_object.IsEmpty()/* && _object->IsObject()*/) {
        //    HANDLE_SCOPE(scope);
        //    _object->SetInternalField(0, v8::External::New(0));
        //}

        RESET(_object);
        RESET(_script);
        RESET(_context);
    }
    
    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

    static iref<thingface_js_dispatcher> get( const script_handle& scriptpath, const coid::token& bindname, v8::Handle<v8::Context>* );

    static v8::Handle<v8::Value> v8creator_get0(const ARGUMENTS& args, interface_context* ifc);

    ///Handler for generic $query_interface javascript method
    static CBK_RET v8query_interface( const ARGUMENTS& args );
    static CBK_RET v8query_interface_global( const ARGUMENTS& args );
    static CBK_RET v8log( const ARGUMENTS& args );
    static CBK_RET v8rebind_events( const ARGUMENTS& args );
    static CBK_RET v8current_global( const ARGUMENTS& args );

    // --- method wrappers ---

    static CBK_RET v8_hallo0( const ARGUMENTS& args );
    static CBK_RET v8_fallo1( const ARGUMENTS& args );

    // --- interface events ---

    virtual void boo( const char* key ) override;

    virtual bool is_bound_boo() override { return is_event_bound(0); }

    virtual void force_bind_script_events() {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::Context::Scope context_scope(LOCAL(iso, _context));
        HANDLE_SCOPE(iso, handle_scope__);
        v8::TryCatch trycatch__;

        bind_events(LOCAL(iso, _context), true, v8::Local<v8::Value>());
    }

private:
    bool is_event_bound( int id )
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        
        if(!_bound_events) {
            v8::Context::Scope context_scope(LOCAL(iso, _context));
            HANDLE_SCOPE(iso, handle_scope__);
            v8::TryCatch trycatch__;

            bind_events(LOCAL(iso, _context), false, UNDEFINED);
        }

        return !_events[id].IsEmpty() && !LOCAL(iso, _events[id])->IsUndefined();
    }

    //event wrappers for event invocation from js
    static CBK_RET v8_evback_boo0(const ARGUMENTS& args);
};

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8_hallo0( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() < 2 || args.Length() > 2) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "thingface.hallo";
        return (CBK_RET)::js::THROW(iso, v8::Exception::SyntaxError, tmp);
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ::js::interface_wrapper_base<ifc1::ifc2::thingface>* ifc = static_cast<::js::interface_wrapper_base<ifc1::ifc2::thingface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if(!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "thingface.hallo";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(LOCAL(iso, ifc->_context));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'" );
    int a;
    v8_streamer<int>::from_v8(args[0], a);

    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator 'coid::charstr'" );
    coid::charstr b;
    v8_streamer<coid::charstr>::from_v8(args[1], b);

    //invoke
    coid::charstr c;

    int _rval_ = R_->hallo(a, b, c);

    //stream out
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    v8::Handle<v8::Object> r__ = NEWTYPE(iso, Object);
    r__->Set(v8::symbol("$ret"), v8_streamer<int>::to_v8(_rval_));

    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
    r__->Set(v8::symbol("c"), v8_streamer<coid::charstr>::to_v8(c));
 
#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return (CBK_RET)::js::THROW(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8_fallo1( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() < 2 || args.Length() > 2) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "thingface.fallo";
        return (CBK_RET)::js::THROW(iso, v8::Exception::SyntaxError, tmp);
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ::js::interface_wrapper_base<ifc1::ifc2::thingface>* ifc = static_cast<::js::interface_wrapper_base<ifc1::ifc2::thingface>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if(!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "thingface.fallo";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(LOCAL(iso, ifc->_context));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
    static_assert( CHECK::meta_operator_exists<bool>::value, "missing metastream operator 'bool'" );
    bool b;
    v8_streamer<bool>::from_v8(args[0], b);

    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator 'coid::charstr'" );
    coid::charstr str;
    v8_streamer<coid::charstr>::from_v8(args[1], str);

    //invoke
    coid::charstr _rval_ = R_->fallo(b, str.c_str());

    //stream out
    v8::Handle<v8::Value> r__;
    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
    r__ = v8_streamer<coid::charstr>::to_v8(_rval_);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return (CBK_RET)::js::THROW(iso, &v8::Exception::TypeError, e.text());
    }
}

////////////////////////////////////////////////////////////////////////////////
void thingface_js_dispatcher::boo( const char* key )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();
    
    v8::Context::Scope context_scope(LOCAL(iso, _context));
    HANDLE_SCOPE(iso, handle_scope__);
    v8::TryCatch trycatch__;

    bind_events(LOCAL(iso, _context), false, UNDEFINED);
    auto ev__ = LOCAL(iso, _events[0]);

    if(_events[0].IsEmpty() || ev__->IsUndefined())
        return;

    THREAD_SINGLETON(v8_streamer_context).reset();
  
    static_assert( CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'" );
    v8::Handle<v8::Value> __inargs[] = {
        v8_streamer<coid::charstr>::to_v8(key),
    };

    v8::Local<v8::Value> r__ = ev__->Call(
        LOCAL(iso, _object),
        //_eventobj.IsEmpty() || LOCAL(iso,_eventobj)->IsUndefined() ? LOCAL(iso,_object) : LOCAL(iso,_eventobj),
        1, __inargs);


    if(trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "ifc1::ifc2::js::thingface.boo(): ");

}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8_evback_boo0( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = LOCAL(iso, ifc->_context);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch trycatch__;

    ifc->bind_events(ctx, false, UNDEFINED);
    auto ev__ = LOCAL(iso, ifc->_events[0]);

    if(ifc->_events[0].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "boo";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Value> largs[1];
    int nargs = args.Length();
    if(nargs > 1)
        nargs = 1;
    for(int i=0; i<nargs; ++i)
        largs[i] = args[i];

    v8::Local<v8::Value> r__ = ev__->Call(
        LOCAL(iso, ifc->_object),
        //ifc->_eventobj.IsEmpty() || LOCAL(iso, ifc->_eventobj)->IsUndefined() ? LOCAL(iso, ifc->_object) : LOCAL(iso, ifc->_eventobj),
        nargs, largs);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return ESCAPE(handle_scope__, r__);
#endif
}


////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8log( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() == 0)
        return CBK_UNDEFINED;
        
    const void* inst = 0;

    v8::Local<v8::Object> obj__ = args.Holder();
    if(!obj__.IsEmpty() && obj__->InternalFieldCount() > 0) {
        v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
        if(intobj__->IsExternal()) {
            ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
                (v8::Handle<v8::External>::Cast(intobj__)->Value());

            inst = ifc;
            if(!ifc)
                return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, "Null interface object in $log");
        }
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    coid::token tokey(*key, key.length());

    intergen_interface::ifclog_ext(coid::ELogType::None, coid::tokenhash("ifc1::ifc2::thingface"),
        inst, tokey);
    
    return CBK_UNDEFINED;
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8query_interface( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() < 1)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::Error, "Interface creator name missing");

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if(!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return (CBK_RET)::js::THROW(iso, v8::Exception::Error, tmp);
    }

    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if(!ifc)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, "Null interface object in $query_interface");

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, ifc));
#else
    return ESCAPE(handle_scope__, get(args, ifc));
#endif
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8query_interface_global( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() < 1)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::Error, "Interface creator name missing");

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if(!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return (CBK_RET)::js::THROW(iso, v8::Exception::Error, tmp);
    }
    
#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, 0));
#else
    return ESCAPE(handle_scope__, get(args, 0));
#endif
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8rebind_events( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();
    HANDLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if(ifc) {
        v8::Local<v8::Value> val;
        if(args.Length() > 0)
            val = args[0];
        ifc->bind_events(LOCAL(iso, ifc->_context), true, val);
    }

    return CBK_UNDEFINED;
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET thingface_js_dispatcher::v8current_global( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();
    
    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if(obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if(!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());
        
#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(LOCAL(iso, ifc->_context)->Global()->GetPrototype());
#else
    return ESCAPE(handle_scope__, LOCAL(iso, ifc->_context)->Global()->GetPrototype());
#endif
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> thingface_js_dispatcher::create_interface_object( bool make_weak )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if(_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = NEWTYPE(iso, ObjectTemplate);
        ot->SetInternalFieldCount(2);    //ptr and class hash id

        ot->Set(v8::symbol("hallo"), NEWTYPE2(iso, FunctionTemplate, &v8_hallo0));
        ot->Set(v8::symbol("fallo"), NEWTYPE2(iso, FunctionTemplate, &v8_fallo1));

        ot->Set(v8::symbol("$query_interface"), NEWTYPE2(iso, FunctionTemplate, &v8query_interface));
        ot->Set(v8::symbol("$rebind_events"), NEWTYPE2(iso, FunctionTemplate, &v8rebind_events));
        ot->Set(v8::symbol("$ctx"), NEWTYPE2(iso, FunctionTemplate, &v8current_global));
        ot->Set(v8::symbol("$log"), NEWTYPE2(iso, FunctionTemplate, &v8log));

        //event wrappers for event invocation from outside js
        ot->Set(v8::symbol("boo"), NEWTYPE2(iso, FunctionTemplate, &v8_evback_boo0));

        PERSISTENT(iso, _objtempl, ot);
    }

    v8::Local<v8::Object> obj = LOCAL(iso, _objtempl)->NewInstance();

    v8::Handle<v8::External> map_ptr = NEWTYPE2(iso, External, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = NEWTYPE2(iso, External, (void*)ints(1521478720));
    obj->SetInternalField(1, hash_ptr);

    if(make_weak) {
        //v8::Persistent<v8::Object> persobj;
        PERSISTENT(iso, _object, obj);
        
#ifdef V8_MAJOR_VERSION
        void* p = this;
        _object.SetWeak(&p, _js_release_callback);
#else
        _object.MakeWeak(this, _js_release_callback);
#endif
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> thingface_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    v8::Local<v8::String> scriptv8 = v8::string_utf8(script);

    // set up an error handler to catch any exceptions the script might throw.
    v8::TryCatch trycatch__;

    v8::Handle<v8::Script> compiled_script = v8::Script::Compile(scriptv8, v8::string_utf8(fname));
    if(trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "ifc1::ifc2::js::thingface::load_script(): ");

    compiled_script->Run();
    if(trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "ifc1::ifc2::js::thingface::load_script(): ");

    return compiled_script;
}

////////////////////////////////////////////////////////////////////////////////
void thingface_js_dispatcher::bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref )
{
    if(!force && _bound_events)
        return;

    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static token names[] = {
        "boo",
    };

    HANDLE_SCOPE(iso, handle_scope__);
    v8::TryCatch trycatch__;
    v8::Local<v8::Object> global;
    bool clear = false;
    if(ref.IsEmpty() || ref->IsUndefined())
        global = context->Global();
    else if(ref->IsNull())
        clear = true;
    else
        global = ref->ToObject();

    for(int i=0; i<1; ++i)
    {
        RESET(_events[i]);

        if(clear)
            continue;

        v8::Local<v8::Value> var = global->Get(v8::string_utf8(names[i]));
        if(var->IsUndefined())
            continue;

        v8::Local<v8::Function> foo = v8::Local<v8::Function>::Cast(var);
        bool failed = trycatch__.HasCaught() || foo->IsUndefined();

        if(!failed)
             PERSISTENT(iso, _events[i], foo);
    }

    _bound_events = true;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<thingface_js_dispatcher> thingface_js_dispatcher::get( const script_handle& script, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    //v8::Persistent<v8::Context> context_per;
    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Handle<v8::Context> context;

    //iref<policy_intrusive_base> extref;

    // create interface object
    iref<thingface_js_dispatcher> ifc = ifc1::ifc2::thingface::get(new thingface_js_dispatcher);
    if(!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if(script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if(ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if(!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
        }
    }

    bool extctx = !context.IsEmpty();

    if(!extctx) {
        if(script.has_context())
            context = script.context();
        else
            context = NEWTYPE(iso, Context);
    }

    if(ctx)
        *ctx = context;

    v8::Context::Scope context_scope(context);
    PERSISTENT(iso, ifc->_context, context);

    if(!extctx && !script.is_context())
    {
        if(!script.has_context()) {
            context->Global()->Set(v8::string_utf8("$include"), NEWTYPE2(iso, FunctionTemplate, &script_handle::js_include)->GetFunction());
            context->Global()->Set(v8::string_utf8("$query_interface"), NEWTYPE2(iso, FunctionTemplate, &thingface_js_dispatcher::v8query_interface_global)->GetFunction());
            context->Global()->Set(v8::string_utf8("$log"), NEWTYPE2(iso, FunctionTemplate, &thingface_js_dispatcher::v8log)->GetFunction());
        }

        coid::token script_tok;
        coid::charstr script_tmp;
        if(script.is_path()) {
            coid::bifstream bif(script.str());
            if(!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if(script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        PERSISTENT(iso, ifc->_object, ifc->create_interface_object(false));
        if(bindname)
            context->Global()->Set(v8::string_utf8(bindname), LOCAL(iso, ifc->_object));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());

        PERSISTENT(iso, ifc->_script, compiled_script);
    }

    PERSISTENT(iso, ifc->_object, ifc->create_interface_object(false));

    if(bindname)
        context->Global()->Set(v8::string_utf8(bindname), LOCAL(iso, ifc->_object));
    
    if(ctx)
        ESCAPE(handle_scope__, *ctx);

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> thingface_js_dispatcher::v8creator_get0( const ARGUMENTS& args, interface_context* ifc )
{
    v8::Isolate* iso = args.GetIsolate();

    if(args.Length() < 1+0 || args.Length() > 1+0) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "get";
        ::js::THROW(iso, &v8::Exception::Error, tmp);
        return UNDEFINED;
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();

    //ifc1::ifc2::js::thingface_js_dispatcher* ifc = static_cast<ifc1::ifc2::js::thingface_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());
    
#if V8_MAJOR_VERSION
    v8::Local<v8::Context> ctx = ifc
        ? v8::Local<v8::Context>::New(iso, ifc->_context)
        : iso->GetCurrentContext();
#else
    v8::Local<v8::Context> ctx = ifc
        ? *ifc->_context
        : v8::Context::GetCurrent();
#endif

    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    THREAD_SINGLETON(v8_streamer_context).reset();
    
    //invoke
    iref<thingface_js_dispatcher> nifc = ifc1::ifc2::thingface::get(new thingface_js_dispatcher);
    if(nifc)
        PERSISTENT(iso, nifc->_context, ctx);//ifc->_context);

    //stream out
    v8::Handle<v8::Value> r__ = nifc ? v8::Handle<v8::Value>(nifc->create_interface_object(true)) : NULLv8(iso);

    return ESCAPE(handle_scope__, r__);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> create_wrapper_thingface( ::ifc1::ifc2::thingface* orig, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if(!orig) return NULLv8(iso);

    v8::Context::Scope context_scope(context);
    ESCAPABLE_SCOPE(iso, scope);

    iref<ifc1::ifc2::js::thingface_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if(orig->intergen_backend() == intergen_interface::IFC_BACKEND_JS)
        obj = LOCAL(iso, static_cast<thingface_js_dispatcher*>(orig)->_object);
    
    if(obj.IsEmpty()) {
        // create interface object
        ifc.create(new ifc1::ifc2::js::thingface_js_dispatcher(context, static_cast<::ifc1::ifc2::thingface*>(orig)));

        obj = ifc->create_interface_object(true);
    }

    return ESCAPE(scope, obj);
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_thingface( bool on )
{
    interface_register::register_interface_creator(
        "ifc1::ifc2::js::thingface.get@creator",
        on ? (void*)&thingface_js_dispatcher::get : nullptr);
    interface_register::register_interface_creator(
        "ifc1::ifc2::js::thingface.get",
        on ? (void*)&thingface_js_dispatcher::v8creator_get0 : nullptr);
    interface_register::register_interface_creator(
        "ifc1::ifc2::js::thingface@wrapper",
        on ? (void*)&create_wrapper_thingface : nullptr);

}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) thingface_autoregger = new ifc_autoregger(&register_binders_for_thingface);


void* force_register_js_thingface() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_thingface);
    return autoregger.get();
}

} //namespace js
} //namespace ifc1
} //namespace ifc2

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> js_ifc1_ifc2_thingface_create_wrapper( const iref<ifc1::ifc2::thingface>& orig, v8::Handle<v8::Context> context )
{
    return ifc1::ifc2::js::create_wrapper_thingface(orig.get(), context);
}
