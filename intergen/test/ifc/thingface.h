#pragma once

#ifndef __INTERGEN_GENERATED__thingface_H__
#define __INTERGEN_GENERATED__thingface_H__

//@file Interface file for thingface interface generated by intergen
//See LICENSE file for copyright and license information

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>


namespace n1 {
namespace n2 {
    class thing;
}}

namespace ifc1 {
namespace ifc2 {

////////////////////////////////////////////////////////////////////////////////
class thingface
    : public intergen_interface
{
public:

    // --- interface methods ---

    int hallo( int a, const coid::token& b, ifc_out coid::charstr& c );

    coid::charstr fallo( bool b, const char* str );


protected:
    // --- interface events (callbacks from host to client) ---
    // ---       overload these to handle host events       ---

    friend class ::n1::n2::thing;

    virtual void boo( const char* key ) {}

    virtual void force_bind_script_events() {}

public:
    // --- host helpers to check presence of handlers in scripts ---

    virtual bool is_bound_boo() { return true; }

public:
    // --- creators ---

    static iref<thingface> get() {
        return get<thingface>(0);
    }

    template<class T>
    static iref<T> get( T* _subclass_ );

    // --- internal helpers ---

    static const int HASHID = 1521478720;

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        static const coid::tokenhash _name = "ifc1::ifc2::thingface";
        return _name;
    }

    static const coid::token& intergen_default_creator_static( EBackend bck ) {
        static const coid::token _dc("ifc1::ifc2::thingface.get@1521478720");
        static const coid::token _djs("ifc1::ifc2::js::thingface@wrapper");
        static const coid::token _dlua("ifc1::ifc2::lua::thingface@wrapper");
        static const coid::token _dnone;

        switch(bck) {
        case IFC_BACKEND_CXX: return _dc;
        case IFC_BACKEND_JS:  return _djs;
        case IFC_BACKEND_LUA: return _dlua;
        default: return _dnone;
        }
    }


    template<enum EBackend B>
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( EBackend bck ) const override final {
        switch(bck) {
        case IFC_BACKEND_JS: return intergen_wrapper_cache<IFC_BACKEND_JS>();
        case IFC_BACKEND_LUA: return intergen_wrapper_cache<IFC_BACKEND_LUA>();
        default: return 0;
        }
    }

    EBackend intergen_backend() const override { return IFC_BACKEND_CXX; }

    const coid::token& intergen_default_creator( EBackend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

protected:

    typedef void (*cleanup_fn)(thingface*, intergen_interface*);
    cleanup_fn _cleaner;

    ~thingface() {
        VT_CALL(void,(),0)();
        if (_cleaner) _cleaner(this,0);
    }

    thingface() : _cleaner(0)
    {}
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> thingface::get( T* _subclass_ )
{
    typedef iref<T> (*fn_creator)(thingface*);

    static fn_creator create = 0;
    static const coid::token ifckey = "ifc1::ifc2::thingface.get@1521478720";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create)
        throw coid::exception("interface creator inaccessible: ") << ifckey;

    return create(_subclass_);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline int thingface::hallo( int a, const coid::token& b, coid::charstr& c )
{ return VT_CALL(int,(int,const coid::token&,coid::charstr&),1)(a,b,c); }

inline coid::charstr thingface::fallo( bool b, const char* str )
{ return VT_CALL(coid::charstr,(bool,const char*),2)(b,str); }

#pragma warning(pop)

} //namespace
} //namespace

#endif //__INTERGEN_GENERATED__thingface_H__
