#pragma once

#ifndef __INTERGEN_GENERATED__$name$_H__
#define __INTERGEN_GENERATED__$name$_H__

//@file Interface file for $name$ interface generated by intergen
//See LICENSE file for copyright and license information

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

$-(if base?)$#include "$baseclass$.h"$(/if)$

$-[pasters]-$
$@value$
$-[/pasters]$

$-[classnsx after="    "]$namespace $@value$ {
$[/classnsx]-$
class $class$;
$[classnsx]$}$[/classnsx]$

$-[ns]$
namespace $@value$ {
$-[/ns]$

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$
    : public $(if base?)$$base$$(elif)$intergen_interface$(/if)$
{
public:

    // --- interface methods ---

$-[method !static? !destroy?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    $(if ..virtual?)$virtual $(/if)$$return.type$ $name$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) $-(if const?)$ const$(/if)$ $-(if ..virtual?)$ = 0$(/if)$;
$[/method]-$
$-(if !event.empty?)$

protected:
    // --- interface events (callbacks from host to client) ---
    // ---       overload these to handle host events       ---

    friend class ::$classnsx rest="::" after="::"$$class$;

$-[event !static?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) $-(if const?)$ const$(/if)$
    $-(if return.type?="void")$ {}$(elif default_event_body?)$ { $default_event_body$ }$(elif)${ throw coid::exception("handler not implemented"); }$(/if)$
$[/event]-$

    virtual void force_bind_script_events() {}

public:
    // --- host helpers to check presence of handlers in scripts ---

$-[event !static?]$
    virtual bool is_bound_$name$() { return true; }
$-[/event]$

public:
$-(/if)$
    // --- creators ---

$-[method static?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$> $name$(
        $-[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) {
        return $name$<$..name$>(0$[args]$, $name$$[/args]$);
    }

    template<class T>
    static iref<T> $name$( T* _subclass_$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ );
$-[/method]$

    // --- internal helpers ---
$-(if varname? destroy.name.empty?)$

    virtual ~$name$() {
        if (_cleaner) _cleaner(this,0);
    }
$-(/if)$

    static const int HASHID = $hash$;

    int intergen_hash_id() const override $-(if !virtual?)$ final$(/if)$ { return HASHID; }

    bool iface_is_derived( int hash ) const override $-(if !virtual?)$ final$(/if)$ {
        return hash == HASHID $-(if base?)$ || $base$::iface_is_derived(hash)$(/if)$;
    }

    const coid::tokenhash& intergen_interface_name() const override $-(if !virtual?)$ final$(/if)$ {
        static const coid::tokenhash _name = "$ns rest="::" after="::"$$name$";
        return _name;
    }

    static const coid::token& intergen_default_creator_static( EBackend bck ) {
$-(if default_creator.name.empty?)$
        static const coid::token _dc("");
$-(elif)$
        static const coid::token _dc("$ns rest="::" after="::"$$name$.$default_creator.name$@$hash$");
$-(/if)$
        static const coid::token _djs("$ns rest="::" after="::"$$name$@wrapper.js");
        static const coid::token _dlua("$ns rest="::" after="::"$$name$@wrapper.lua");
        static const coid::token _dnone;

        switch(bck) {
        case IFC_BACKEND_CXX: return _dc;
        case IFC_BACKEND_JS:  return _djs;
        case IFC_BACKEND_LUA: return _dlua;
        default: return _dnone;
        }
    }


    template<enum EBackend B>
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( EBackend bck ) const override $-(if !virtual?)$ final$(/if)$ {
        switch(bck) {
        case IFC_BACKEND_JS: return intergen_wrapper_cache<IFC_BACKEND_JS>();
        case IFC_BACKEND_LUA: return intergen_wrapper_cache<IFC_BACKEND_LUA>();
        default: return 0;
        }
    }

    EBackend intergen_backend() const override { return IFC_BACKEND_CXX; }

    const coid::token& intergen_default_creator( EBackend bck ) const override $-(if !virtual?)$ final$(/if)$ {
        return intergen_default_creator_static(bck);
    }

protected:
$-(if varname?)$

    typedef void (*cleanup_fn)($name$*, intergen_interface*);
    cleanup_fn _cleaner;
$-(/if)$
$-(if destroy.name.empty!)$

    ~$name$() {
        VT_CALL($destroy.return.type$,($[destroy.args rest=","]$$type$$[/destroy.args]$),0)($[destroy.args rest=","]$$name$$[/destroy.args]$);
$-(if varname?)$
        if (_cleaner) _cleaner(this,0);
$-(/if)$
    }
$-(/if)$

    $name$()$(if varname?)$ : _cleaner(0)$(/if)$
    {}
};

$-(if !virtual?)$
$-[method static?]$
////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> $..name$::$name$( T* _subclass_
    $-[args]$, $type$ $name$$size$$[/args]$ )
{
    typedef iref<T> (*fn_creator)($..name$*$[args]$, $type$$[/args]$);

    static fn_creator create = 0;
    static const coid::token ifckey = "$..ns rest="::" after="::"$$..name$.$name$@$..hash$";

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create)
        throw coid::exception("interface creator inaccessible: ") << ifckey;

    return create(_subclass_$[args]$, $name$$[/args]$);
}
$-[/method]$

#pragma warning(push)
#pragma warning(disable : 4191)

$-[method !static? !destroy?]$
inline $return.type$ $..name$::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$) $-(if const?)$ const$(/if)$
{ return VT_CALL($return.type$,($[args rest=","]$$type$$size$$[/args]$) $-(if const?)$ const$(/if)$,$index$)($[args rest=","]$ $-(if xref?)$std::forward<$basetype$>($(/if)-$ $name$ $-(if xref?)$)$(/if)-$ $[/args]$); }
$[/method]-$

#pragma warning(pop)
$(/if)-$

$-[ns]$
} //namespace
$-[/ns]$

#endif //__INTERGEN_GENERATED__$name$_H__
