
//@file  interface dispatcher generated by intergen v8
//See LICENSE file for copyright and license information

#include "ifc/component_ifc.h"
#include "data.hpp"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>

static_assert(intergen_interface::VERSION == 8, "interface must be rebuilt with a different intergen version");

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
// data interface component_ifc of class component


///
class component_ifc_data_dispatcher : public component_ifc
{
private:

    inline static ifn_t _fn_table[] = {
        reinterpret_cast<ifn_t>((void(intergen_data_interface::*)(int))(&::component::set_a)),
        reinterpret_cast<ifn_t>((void(intergen_data_interface::*)(const coid::token&,int*))(&::component::set_b)),
        nullptr
    };
    inline static icr_t _cr_table[] = {
        reinterpret_cast<icr_t>(&::component::creator),
        nullptr
    };

protected:

    COIDNEWDELETE(component_ifc_data_dispatcher);

    component_ifc_data_dispatcher() = default;
    ~component_ifc_data_dispatcher() = default;

public:

    static void register_interfaces(bool on)
    {
        coid::ifcman::set_type_ifc<component_ifc>(HASHID, _cr_table, _fn_table);
    }
};


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) component_ifc_autoregger = new ifc_autoregger(&component_ifc_data_dispatcher::register_interfaces);

void* force_register_component_ifc() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&component_ifc_data_dispatcher::register_interfaces);
    return autoregger.get();
}


