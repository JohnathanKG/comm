
//@file $name$ javascript interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

$-[class]$$[iface]$
#include "$relpathjs$"
$-[/iface]$$[/class]$

using namespace coid;

#ifdef V8_MAJOR_VERSION

#define UNDEFINED           v8::Local<v8::Value>()
#define NULLv8(iso)         v8::Null(iso)

#define HANDLE_SCOPE(iso,hs)    v8::HandleScope hs(iso)
#define ESCAPABLE_SCOPE(iso,hs) v8::EscapableHandleScope hs(iso)
#define ESCAPE(hs,h)        hs.Escape(h)

#define ARGUMENTS           v8::FunctionCallbackInfo<v8::Value>
#define CBK_RET             void
#define CBK_UNDEFINED

#define NEWTYPE(iso,t)      v8::t::New(iso)
#define NEWTYPE2(iso,t,a)   v8::t::New(iso, a)
#define PERSISTENT(iso,o,n) o.Reset(iso, n)
#define RESET(o)            o.Reset()
#define LOCAL(iso,o)        o.Get(iso)
#define CUR_CONTEXT(iso)    iso->GetCurrentContext()

#else

#define UNDEFINED           v8::Undefined()
#define NULLv8(iso)         v8::Null()

#define HANDLE_SCOPE(iso,hs)    v8::HandleScope hs
#define ESCAPABLE_SCOPE(iso,hs) v8::HandleScope hs
#define ESCAPE(hs,h)        hs.Close(h)

#define ARGUMENTS           v8::Arguments
#define CBK_RET             v8::Handle<v8::Value>
#define CBK_UNDEFINED       v8::Undefined()

#define NEWTYPE(iso,t)      v8::t::New()
#define NEWTYPE2(iso,t,a)   v8::t::New(a)
#define PERSISTENT(iso,o,n) o = o.New(iso,n)
#define RESET(o)            do { if (!o.IsWeak()) o.Dispose(); o.Clear(); } while(0)
#define LOCAL(iso,o)        o
#define CUR_CONTEXT(iso)    v8::Context::GetCurrent()

#endif

$-[class]$$[iface rest="\n\n"]$
////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface $name$ of class $..class$
//
////////////////////////////////////////////////////////////////////////////////

$-[ns]$
namespace $@value$ {
$-[/ns]$
namespace js {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_js_dispatcher
    : public ::js::interface_wrapper_base<$ns rest="::"$::$name$>
{
$-(if event?)$
    v8::Persistent<v8::Function> _events[$event.@size$];
    //v8::Persistent<v8::Object> _eventobj;
    bool _bound_events;

$-(/if)$
$-(if hasprops?)$
    static v8::Handle<v8::Value> _getter(v8::Local<v8::String> property, const v8::AccessorInfo &info);
    static v8::Handle<v8::Value> _setter(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::AccessorInfo &info);

$-(/if)$
#ifdef V8_MAJOR_VERSION
    static void _js_release_callback(const v8::WeakCallbackInfo<void*>& data)
    {
        void* p = data.GetParameter();
        $name$_js_dispatcher* ifc = static_cast<$name$_js_dispatcher*>(p);
        ifc->_object.Empty();
        ifc->release_refcount();
    }

#else

    static void _js_release_callback(v8::Persistent<v8::Value> object, void* p)
    {
        $name$_js_dispatcher* ifc = static_cast<$name$_js_dispatcher*>(p);
        DASSERT( ifc->_object == object );
        ifc->_object.Clear();
        ifc->release_refcount();

        object.Dispose();
    }
#endif

protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_JS; }

public:

    v8::Handle<v8::Object> create_interface_object( bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& scriptfile, const coid::token& file_name );
$-(if event?)$
    void bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref );
$-(/if)$

    COIDNEWDELETE("$[ns]$$@value$::$[/ns]$$name$_js_dispatcher");

    $name$_js_dispatcher() $-(if event?)$ : _bound_events(false)$(/if)$
    {}

    $name$_js_dispatcher( $ns rest="::" after="::"$$name$* orig ) $(if event?)$: _bound_events(false) $(/if)${
        _base.create(orig);
        _vtable = _base->vtable();
        //PERSISTENT(v8::Isolate::GetCurrent(), _context, context);

		_host = _base->host<policy_intrusive_base>();
    }

    ~$name$_js_dispatcher() {
$-(if event?)$
        //RESET(_eventobj);

        for (int i=0; i<$event.@size$; ++i) {
            RESET(_events[i]);
        }

$-(/if)$
        RESET(_object);

        //RESET(_script);
        //RESET(_context);
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

$-[method static?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_js_dispatcher> $name$( const script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>* );

    $-(if !internal?)$
    static v8::Handle<v8::Value> v8creator_$name$$@order$(const ARGUMENTS& args, interface_context* ifc);

    $-(/if)$
$-[/method]$
    ///Handler for generic $$query_interface javascript method
    static CBK_RET v8query_interface( const ARGUMENTS& args );
    static CBK_RET v8query_interface_global( const ARGUMENTS& args );
    static CBK_RET v8log( const ARGUMENTS& args );
    static CBK_RET v8rebind_events( const ARGUMENTS& args );
    static CBK_RET v8current_global( const ARGUMENTS& args );

    // --- method wrappers ---

$-[method !static? !destroy? !internal? !operator?]$
    static CBK_RET v8_$name$$@index$( const ARGUMENTS& args );
$-[/method]$
$-(if event.empty!)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) override;
$-[/event]$

$-[event]$
    virtual bool is_bound_$name$() override { return is_event_bound($@index$); }
$-[/event]$

    virtual void force_bind_script_events() {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        //v8::Context::Scope context_scope(LOCAL(iso, _context));
        HANDLE_SCOPE(iso, handle_scope__);
        v8::TryCatch trycatch__;

        bind_events(context(iso), true, v8::Local<v8::Value>());
    }

private:
    bool is_event_bound( int id )
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();

        if (!_bound_events) {
            //v8::Context::Scope context_scope(LOCAL(iso, _context));
            HANDLE_SCOPE(iso, handle_scope__);
            v8::TryCatch trycatch__;

            bind_events(context(iso), false, UNDEFINED);
        }

        return !_events[id].IsEmpty() && !LOCAL(iso, _events[id])->IsUndefined();
    }

    //event wrappers for event invocation from js
$-[event]$
    static CBK_RET v8_evback_$name$$@index$(const ARGUMENTS& args);
$-[/event]$
$-(/if)$
};

$-[method !static? !destroy? !internal? !operator?]$
////////////////////////////////////////////////////////////////////////////////
CBK_RET $..name$_js_dispatcher::v8_$name$$@index$( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < $ninargs_nondef$ || args.Length() > $ninargs$) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$..name$.$name$";
        return (CBK_RET)::js::THROW(iso, v8::Exception::SyntaxError, tmp);
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return CBK_UNDEFINED;

    ::js::interface_wrapper_base<$..ns rest="::"$::$..name$>* ifc = static_cast<::js::interface_wrapper_base<$..ns rest="::"$::$..name$>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$.$name$";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    try {
    THREAD_SINGLETON(v8_streamer_context).reset();

    //stream the arguments in
$-[args inarg? !nojs?]$
 $-(if iref.false?)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator '$basetype$'");
 $-(/if)$
$-[/args]$

$-[args inarg? !nojs?]$
  $-(if !defval.empty? ptr.true?)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if ($@order$ < args.Length())
        from_v8(args[$@order$], $name$__tmp);
    else
        $name$ = $defval$;
  $-(elif !defval.empty?)$
    threadcached<$basetype$> $name$;
    if ($@order$ < args.Length())
        from_v8(args[$@order$], $name$);
    else
        $name$ = $defval$;
  $-(elif)$
    threadcached<$basetype$> $name$;
    from_v8(args[$@order$], $name$);
  $-(/if)$
$[/args]-$

    //invoke
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    $(if return.type!="void")$$return.type$ _rval_ = $(/if)$R_->$name$($[args rest=", "]$ $-(if ptr? outarg?)$&$-(elif ptr? defval.empty? !specptr?)$&$(/if)$ $-(if nojs?)$$defval$$(elif)$$name$$(/if)$$[/args]$);

    //stream out
$-(if return.type!="void")$
 $-(if return.iref.false? noutargs?)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
    v8::Handle<v8::Object> r__ = NEWTYPE(iso, Object);
    r__->Set(v8::symbol("$$ret"), to_v8(_rval_));
 $-(elif noutargs?)$
    v8::Handle<v8::Object> r__ = NEWTYPE(iso, Object);
    r__->Set(v8::symbol("$$ret"), ::js::wrap_object(_rval_.get(), ifc->context(iso)));
 $-(elif return.iref.false?)$
    v8::Handle<v8::Value> r__;
  $-(if return.ptr.true?)$
    static_assert( CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'" );
    if (_rval_)
        r__ = to_v8(*_rval_);
  $-(elif)$
    static_assert( CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'" );
    r__ = to_v8(_rval_);
  $-(/if)$
 $-(elif)$
    v8::Handle<v8::Value> r__ = ::js::wrap_object(_rval_.get(), ifc->context(iso));
 $-(/if)$

 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
    r__->Set(v8::symbol("$name$"), to_v8($name$));
  $-(elif)$
    r__->Set(v8::symbol("$name$"), ::js::wrap_object($name$.get(), ifc->context(iso)));
  $-(/if)$
 $[/args]-$
$-(elif noutargs?="1")$
 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
    v8::Handle<v8::Value> r__ = to_v8($name$);
  $-(elif)$
    v8::Handle<v8::Value> r__ = ::js::wrap_object(_rval_.get(), ifc->context(iso));
  $-(/if)$
 $[/args]-$
$-(elif noutargs?)$
    v8::Handle<v8::Object> r__ = NEWTYPE(iso, Object);
 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
    r__->Set(v8::symbol("$name$"), to_v8($name$));
  $-(elif)$
    r__->Set(v8::symbol("$name$"), ::js::wrap_object($name$.get(), ifc->context(iso)));
  $-(/if)$
 $[/args]-$
$-(elif)$
    v8::Handle<v8::Object> r__;
$(/if)-$

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return ESCAPE(handle_scope__, r__);
#endif

    } catch(const coid::exception& e) {
        return (CBK_RET)::js::THROW(iso, &v8::Exception::TypeError, e.text());
    }
}

$-[/method]$
$-[event]$
////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_js_dispatcher::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

$-(if internal?)$
    throw coid::exception("method not marked for scripting");
$-(elif)$
    HANDLE_SCOPE(iso, handle_scope__);
    v8::Context::Scope context_scope__(context(iso));
    v8::TryCatch trycatch__;

    bind_events(context(iso), false, UNDEFINED);
    auto ev__ = LOCAL(iso, _events[$@index$]);

    if (_events[$@index$].IsEmpty() || ev__->IsUndefined())
  $-(if default_event_body?)$ {
        $default_event_body$; $-(if return.type?="void")$
        return;
        $-(/if)$
    }
  $-(elif !mandatory?)$
        return;
  $-(elif)$
        throw coid::exception("handler not implemented");
  $-(/if)$

// prepare in arguments
    THREAD_SINGLETON(v8_streamer_context).reset();

$-[args inarg? iref.false?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
$-[/args]$
$-(if ninargs?)$
    v8::Handle<v8::Value> __inargs[] = {
$-[args inarg? rest=","]$
        v8_streamer$(if volatile ? )$_volatile$(/ if)$<$basetype$>::to_v8($name$)
$-[/args]$
    };

$-(/if)$
//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        LOCAL(iso, _object),
        //_eventobj.IsEmpty() || LOCAL(iso,_eventobj)->IsUndefined() ? LOCAL(iso,_object) : LOCAL(iso,_eventobj),
        $(if ninargs?)$$ninargs$, __inargs$(elif)$0, 0$(/if)$);

$-[args inarg?]$$(if volatile?)$
    v8_streamer$(if volatile?)$_volatile$(/if)$<$basetype$>::cleanup(__inargs[$@order$]);$(/if)$
$-[/args]$

    if (trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "$..ns rest="::" after="::"$js::$..name$.$name$(): ");
// gather results
$-(if !noutargs?)$

 $-(if return.type!="void")$
  $-(if return.iref.true?)$
    $return.type$ _rval_;
  $-(elif)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
    threadcached<$return.type$> _rval_;
  $-(/if)$
    from_v8(r__, _rval_);
 $-(/if)$
$-(elif)$
 $-(if return.type?="void" noutargs?="1")$

  $-[args outarg?]$
   $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
   $-(/if)$
   $-(if ptr?)$
    if ($name$)
        from_v8(r__, *$name$);
   $-(elif)$
    from_v8(r__, $name$);
   $-(/if)$
  $-[/args]$
 $-(elif)$

    if (!r__->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> obj__ = r__->ToObject();
  $-(if return.type!="void")$

    //return value
   $-(if return.iref.true?)$
    $return.type$ _rval_;
   $-(elif)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
    threadcached<$return.type$> _rval_;
   $-(/if)$
    from_v8(r__, _rval_);
  $-(/if)$
  $-[args outarg?]$

   $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
   $-(/if)$
   $-(if ptr?)$
    if ($name$)
        from_v8(obj__->Get(v8::symbol("$name$")), *$name$);
   $-(elif)$
    from_v8(obj__->Get(v8::symbol("$name$")), $name$);
   $-(/if)$
  $-[/args]$
 $-(/if)$
$(/if)-$

$-(if return.type!="void")$
    return _rval_;
$-(/if)$
$-(/if)$
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET $..name$_js_dispatcher::v8_evback_$name$$@index$( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return CBK_UNDEFINED;

    $..ns rest="::" after="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns rest="::" after="::"$js::$..name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch trycatch__;

    ifc->bind_events(ctx, false, UNDEFINED);
    auto ev__ = LOCAL(iso, ifc->_events[$@index$]);

    if (ifc->_events[$@index$].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "$name$";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }
$-(if ninargs.nonzero?)$

    v8::Local<v8::Value> largs[$ninargs$];
    int nargs = args.Length();
    if (nargs > $ninargs$)
        nargs = $ninargs$;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];
$-(/if)$

    v8::Local<v8::Value> r__ = ev__->Call(
        LOCAL(iso, ifc->_object),
        //ifc->_eventobj.IsEmpty() || LOCAL(iso, ifc->_eventobj)->IsUndefined() ? LOCAL(iso, ifc->_object) : LOCAL(iso, ifc->_eventobj),
        $(if ninargs?)$nargs, largs$(elif)$0, 0$(/if)$);

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(r__);
#else
    return ESCAPE(handle_scope__, r__);
#endif
}

$-[/event]$
$-(if hasprops?)$
////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $name$_js_dispatcher::_getter(v8::Local<v8::String> property, const v8::AccessorInfo &info)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = info.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return UNDEFINED;

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[]";
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    v8::String::Utf8Value key(property);
    coid::token tok(*key, key.length());

 $-(if getter.token?)$
    $getter.basetype$ value = (*R_)(tok);
 $-(elif)$
    $getter.basetype$ value = (*R_)(*key);
 $-(/if)$

    //stream out
 $-(if getter.iref.false?)$
    THREAD_SINGLETON(v8_streamer_context).reset();

    static_assert( CHECK::meta_operator_exists<$getter.basetype$>::value, "missing metastream operator for '$getter.basetype$'" );
    v8::Handle<v8::Value> r__ = to_v8(value);
 $-(elif)$
    v8::Handle<v8::Value> r__ = ::js::wrap_object(value.get(), ifc->context(iso));
 $-(/if)$

    return ESCAPE(handle_scope__, r__);
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $name$_js_dispatcher::_setter(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::AccessorInfo &info)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = info.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return UNDEFINED;

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[] = ...";
        return (CBK_RET)::js::THROW(iso, v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));
    THREAD_SINGLETON(v8_streamer_context).reset();

    static_assert( CHECK::meta_operator_exists<$setter.basetype$>::value, "missing metastream operator for '$setter.basetype$'" );
    threadcached<$setter.basetype$> val;
    from_v8(value, val);

    v8::String::Utf8Value key(property);
$-(if setter.token?)$
    (*R_)(coid::token(*key, key.length()), val);
$-(elif)$
    (*R_)(*key, val);
$-(/if)$

    return ESCAPE(handle_scope__, value);
}
$-(/if)$

////////////////////////////////////////////////////////////////////////////////
CBK_RET $name$_js_dispatcher::v8log( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() == 0)
        return CBK_UNDEFINED;

    const void* inst = 0;

    v8::Local<v8::Object> obj__ = args.Holder();
    if (!obj__.IsEmpty() && obj__->InternalFieldCount() > 0) {
        v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
        if (intobj__->IsExternal()) {
            $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
                (v8::Handle<v8::External>::Cast(intobj__)->Value());

            inst = ifc;
            if (!ifc)
                return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, "Null interface object in $$log");
        }
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    coid::token tokey(*key, key.length());

    intergen_interface::ifclog_ext(coid::ELogType::None, coid::tokenhash("$ns rest="::" after="::"$$name$"),
        inst, tokey);

    return CBK_UNDEFINED;
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET $name$_js_dispatcher::v8query_interface( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::Error, "Interface creator name missing");

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return (CBK_RET)::js::THROW(iso, v8::Exception::Error, tmp);
    }

    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return CBK_UNDEFINED;

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if (!ifc)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::ReferenceError, "Null interface object in $$query_interface");

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, ifc));
#else
    return ESCAPE(handle_scope__, get(args, ifc));
#endif
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET $name$_js_dispatcher::v8query_interface_global( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1)
        return (CBK_RET)::js::THROW(iso, &v8::Exception::Error, "Interface creator name missing");

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::String::Utf8Value key(args[0]);

    typedef v8::Handle<v8::Value> (*fn_get)(const ARGUMENTS&, interface_context*);
    coid::token tokey(*key, key.length());
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(tokey));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << tokey << " not found";
        return (CBK_RET)::js::THROW(iso, v8::Exception::Error, tmp);
    }

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(get(args, 0));
#else
    return ESCAPE(handle_scope__, get(args, 0));
#endif
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET $name$_js_dispatcher::v8rebind_events( const ARGUMENTS& args )
{
$-(if event?)$
    v8::Isolate* iso = args.GetIsolate();
    HANDLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return CBK_UNDEFINED;

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if (ifc) {
        v8::Local<v8::Value> val;
        if (args.Length() > 0)
            val = args[0];
        ifc->bind_events(ifc->context(iso), true, val);
    }

$-(/if)$
    return CBK_UNDEFINED;
}

////////////////////////////////////////////////////////////////////////////////
CBK_RET $name$_js_dispatcher::v8current_global( const ARGUMENTS& args )
{
    v8::Isolate* iso = args.GetIsolate();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return CBK_UNDEFINED;

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return CBK_UNDEFINED;

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

#ifdef V8_MAJOR_VERSION
    args.GetReturnValue().Set(ifc->context(iso)->Global()->GetPrototype());
#else
    return ESCAPE(handle_scope__, ifc->context(iso)->Global()->GetPrototype());
#endif
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> $name$_js_dispatcher::create_interface_object( bool make_weak )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = NEWTYPE(iso, ObjectTemplate);
        ot->SetInternalFieldCount(2);    //ptr and class hash id

$-[method !static? !destroy? !internal? !operator?]$
        ot->Set(v8::symbol("$name$"), NEWTYPE2(iso, FunctionTemplate, &v8_$name$$@index$));
$-[/method]$

        ot->Set(v8::symbol("$$query_interface"), NEWTYPE2(iso, FunctionTemplate, &v8query_interface));
        ot->Set(v8::symbol("$$rebind_events"), NEWTYPE2(iso, FunctionTemplate, &v8rebind_events));
        ot->Set(v8::symbol("$$ctx"), NEWTYPE2(iso, FunctionTemplate, &v8current_global));
        ot->Set(v8::symbol("$$log"), NEWTYPE2(iso, FunctionTemplate, &v8log));
$-(if hasprops?)$

        ot->SetNamedPropertyHandler(&_getter, &_setter);
$-(/if)$
$-(if event.nonzero?)$

        //event wrappers for event invocation from outside js
$-[event]$
        ot->Set(v8::symbol("$name$"), NEWTYPE2(iso, FunctionTemplate, &v8_evback_$name$$@index$));
$-[/event]$
$-(/if)$

        PERSISTENT(iso, _objtempl, ot);
    }

    v8::Local<v8::Object> obj = LOCAL(iso, _objtempl)->NewInstance();

    v8::Handle<v8::External> map_ptr = NEWTYPE2(iso, External, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = NEWTYPE2(iso, External, (void*)ints($hash$));
    obj->SetInternalField(1, hash_ptr);

    if (make_weak) {
        PERSISTENT(iso, _object, obj);

#ifdef V8_MAJOR_VERSION
        void* p = this;
        _object.SetWeak(&p, _js_release_callback, v8::WeakCallbackType::kParameter);
        //_context.SetWeak();
#else
        _object.MakeWeak(this, _js_release_callback);
        //_context.MakeWeak(0, _js_release_callback);
#endif
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> $name$_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    v8::Local<v8::String> scriptv8 = v8::string_utf8(script);

    // set up an error handler to catch any exceptions the script might throw.
    v8::TryCatch trycatch__;

    v8::Handle<v8::Script> compiled_script = v8::Script::Compile(scriptv8, v8::string_utf8(fname));
    if (trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "$ns rest="::" after="::"$js::$name$::load_script(): ");

    compiled_script->Run();
    if (trycatch__.HasCaught())
        script_handle::throw_js_error(trycatch__, "$ns rest="::" after="::"$js::$name$::load_script(): ");

    return compiled_script;
}

$-(if event.empty!)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::bind_events( v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref )
{
    if (!force && _bound_events)
        return;

    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static token names[] = {
$-[event]$
        "$name$",
$-[/event]$
    };

    HANDLE_SCOPE(iso, handle_scope__);
    v8::Context::Scope context_scope__(context);
    v8::TryCatch trycatch__;
    v8::Local<v8::Object> global;
    bool clear = false;
    if (ref.IsEmpty() || ref->IsUndefined())
        global = context->Global();
    else if (ref->IsNull())
        clear = true;
    else
        global = ref->ToObject();

    for (int i=0; i<$event.@size$; ++i)
    {
        RESET(_events[i]);

        if (clear)
            continue;

        v8::Local<v8::Value> var = global->Get(v8::string_utf8(names[i]));
        if (var->IsUndefined())
            continue;

        v8::Local<v8::Function> foo = v8::Local<v8::Function>::Cast(var);
        bool failed = trycatch__.HasCaught() || foo->IsUndefined();

        if (!failed)
             PERSISTENT(iso, _events[i], foo);
    }

    _bound_events = true;
}

$-(/if)$
// --- creators ---

$-[method static?]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_js_dispatcher> $..name$_js_dispatcher::$name$( const script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<$..name$_js_dispatcher> ifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $name$$[/args]$);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else
            context = NEWTYPE(iso, Context);
    }

    if (ctx)
        *ctx = ESCAPE(handle_scope__, context);

    v8::Context::Scope context_scope(context);
    //PERSISTENT(iso, ifc->_context, context);

    if (!extctx && !script.is_context())
    {
        if (!script.has_context()) {
            context->Global()->Set(v8::string_utf8("$$include"), NEWTYPE2(iso, FunctionTemplate, &script_handle::js_include)->GetFunction());
            context->Global()->Set(v8::string_utf8("$$query_interface"), NEWTYPE2(iso, FunctionTemplate, &$..name$_js_dispatcher::v8query_interface_global)->GetFunction());
            context->Global()->Set(v8::string_utf8("$$log"), NEWTYPE2(iso, FunctionTemplate, &$..name$_js_dispatcher::v8log)->GetFunction());
        }

        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        PERSISTENT(iso, ifc->_object, ifc->create_interface_object(false));
        if (bindname)
            context->Global()->Set(v8::string_utf8(bindname), LOCAL(iso, ifc->_object));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());

        //PERSISTENT(iso, ifc->_script, compiled_script);
    }
    else {
        PERSISTENT(iso, ifc->_object, ifc->create_interface_object(false));

        if (bindname)
            context->Global()->Set(v8::string_utf8(bindname), LOCAL(iso, ifc->_object));
    }

    return ifc;
}

$-(if !internal?)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> $..name$_js_dispatcher::v8creator_$name$$@order$( const ARGUMENTS& args, interface_context* ifc )
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+$ninargs_nondef$ || args.Length() > 1+$ninargs$) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$name$";
        ::js::THROW(iso, &v8::Exception::Error, tmp);
        return UNDEFINED;
    }

    ESCAPABLE_SCOPE(iso, handle_scope__);
    v8::Local<v8::Object> obj__ = args.Holder();

    //$..ns rest="::" after="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns rest="::" after="::"$js::$..name$_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = ifc && !ifc->_object.IsEmpty()
        ? ifc->context(iso)
        : CUR_CONTEXT(iso);
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
    THREAD_SINGLETON(v8_streamer_context).reset();

$-[args inarg? !nojs?]$
 $-(if iref.false?)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
 $-(/if)$
$-[/args]$
$-[args inarg? !nojs?]$
 $-(if ptr? !defval.empty?)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if (1 + $@order$ < args.Length())
        from_v8(args[1+$@order$], $name$__tmp);
    else
        $name$ = $defval$;
 $-(elif !defval.empty?)$
    threadcached<$basetype$> $name$;
    if (1 + $@order$ < args.Length())
        from_v8(args[1+$@order$], $name$);
    else
        $name$ = $defval$;
 $-(elif)$
    threadcached<$basetype$> $name$;
    from_v8(args[1+$@order$], $name$);
 $-(/if)$
$[/args]-$

    //invoke
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    iref<$..name$_js_dispatcher> nifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $(if ptr? outarg?)$&$(elif ptr? defval.empty? !specptr?)$&$(/if)$$name$$[/args]$);
    //if (nifc)
    //    PERSISTENT(iso, nifc->_context, ctx);//ifc->_context);

    //stream out
$-(if noutargs?)$
    v8::Handle<v8::Object> r__ = NEWTYPE(iso, Object);
    r__->Set(v8::symbol("$$ret"), nifc ? v8::Handle<v8::Value>(nifc->create_interface_object(true)) : NULLv8(iso));
$-(elif)$
    v8::Handle<v8::Value> r__ = nifc ? v8::Handle<v8::Value>(nifc->create_interface_object(true)) : NULLv8(iso);
$-(/if)$

$-[args outarg?]$
    $-(if iref.false?)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
    $-(/if)$
    r__->Set(v8::symbol("$name$"), to_v8($name$));
$[/args]-$
    
    return ESCAPE(handle_scope__, r__);
}

$-(/if)$
$-[/method]$
$-(if virtual!)$
////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> create_wrapper_$name$( ::$ns rest="::" after="::"$$name$* orig, v8::Handle<v8::Context> context )
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if (!orig) return NULLv8(iso);

    if (context.IsEmpty()) {
        context = CUR_CONTEXT(iso);
    }

    v8::Context::Scope context_scope(context);
    ESCAPABLE_SCOPE(iso, scope);

    iref<$ns rest="::" after="::"$js::$name$_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_JS)
        obj = LOCAL(iso, static_cast<$name$_js_dispatcher*>(orig)->_object);

    if (obj.IsEmpty()) {
        // create interface object
        ifc.create(new $ns rest="::" after="::"$js::$name$_js_dispatcher(static_cast<::$ns rest="::" after="::"$$name$*>(orig)));

        obj = ifc->create_interface_object(true);
    }

    return ESCAPE(scope, obj);
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$( bool on )
{
$-[method static?]$
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$$..name$.$name$@creator.js",
        on ? (void*)&$..name$_js_dispatcher::$name$ : nullptr);
$-(if !internal?)$
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$js::$..name$.$name$",
        on ? (void*)&$..name$_js_dispatcher::v8creator_$name$$@order$ : nullptr);
$-(/if)$
$-[/method]$
$-(if virtual!)$
    interface_register::register_interface_creator(
        "$ns rest="::" after="::"$$name$@wrapper.js",
        on ? (void*)&create_wrapper_$name$ : nullptr);

$-(/if)$
}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);


void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace js
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface]$$[/class]$
