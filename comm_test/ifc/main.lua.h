#pragma once

#ifndef __INTERGEN_GENERATED__main_LUA_H__
#define __INTERGEN_GENERATED__main_LUA_H__

//@file Lua interface file for main interface generated by intergen
//See LICENSE file for copyright and license information

#include "main.h"

#include <comm/intergen/ifc.lua.h>
#include <comm/token.h>

namespace ns {
namespace lua {

class main
{
public:

    //@param script - script for object to bind to
    //@param bindvar - name of variable in script context for object to bind to
    //@param ctx -  
    static iref<ns::main> create( lua_State * L, const ::lua::script_handle& script, const coid::token& bindvar = coid::token(), iref<::lua::registry_handle>* ctx = 0)
    {
        typedef iref<ns::main> (*fn_bind)(lua_State * L, const ::lua::script_handle&, const coid::token&, iref<::lua::registry_handle>*);
        static fn_bind binder = 0;
        static const coid::token ifckey = "ns::lua::main.create@creator";
        
        if(!binder)
            binder = reinterpret_cast<fn_bind>(
                coid::interface_register::get_interface_creator(ifckey));

        if(!binder)
            throw coid::exception("interface binder inaccessible: ") << ifckey;

        return binder(L, script, bindvar, ctx);
    }

    //@param script - script for object to bind to
    //@param bindvar - name of variable in script context for object to bind to
    //@param ctx -  
    static iref<ns::main> create_special( lua_State * L, const ::lua::script_handle& script, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e = -1, const coid::token& bindvar = coid::token(), iref<::lua::registry_handle>* ctx = 0)
    {
        typedef iref<ns::main> (*fn_bind)(lua_State * L, const ::lua::script_handle&, int, iref<ns::other>, int&, iref<ns::other>&, int, const coid::token&, iref<::lua::registry_handle>*);
        static fn_bind binder = 0;
        static const coid::token ifckey = "ns::lua::main.create_special@creator";
        
        if(!binder)
            binder = reinterpret_cast<fn_bind>(
                coid::interface_register::get_interface_creator(ifckey));

        if(!binder)
            throw coid::exception("interface binder inaccessible: ") << ifckey;

        return binder(L, script, a, b, c, d, e, bindvar, ctx);
    }

    //@param script - script for object to bind to
    //@param bindvar - name of variable in script context for object to bind to
    //@param ctx -  
    static iref<ns::main> create_wp( lua_State * L, const ::lua::script_handle& script, int a, int& b, int& c, int d = -1, const coid::token& bindvar = coid::token(), iref<::lua::registry_handle>* ctx = 0)
    {
        typedef iref<ns::main> (*fn_bind)(lua_State * L, const ::lua::script_handle&, int, int&, int&, int, const coid::token&, iref<::lua::registry_handle>*);
        static fn_bind binder = 0;
        static const coid::token ifckey = "ns::lua::main.create_wp@creator";
        
        if(!binder)
            binder = reinterpret_cast<fn_bind>(
                coid::interface_register::get_interface_creator(ifckey));

        if(!binder)
            throw coid::exception("interface binder inaccessible: ") << ifckey;

        return binder(L, script, a, b, c, d, bindvar, ctx);
    }
};

} //namespace lua
} //namespace


#endif //__INTERGEN_GENERATED__main_LUA_H__
