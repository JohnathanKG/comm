
//@file  interface dispatcher generated by intergen v6
//See LICENSE file for copyright and license information

#include "ifc/other.h"
#include "ifc/main.h"
#include "luatest_ifc.hpp"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == 6, "interface must be rebuilt with a different intergen version");

using namespace coid;

static_assert( std::is_base_of<policy_intrusive_base, ns1::other_cls>::value, "class 'other_cls' must be derived from policy_intrusive_base");
static_assert( std::is_base_of<policy_intrusive_base, ns1::other_cls>::value, "class 'other_cls' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface other of class other_cls

namespace ns {

///
class other_dispatcher : public other
{
private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[3];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<const coid::charstr&(policy_intrusive_base::*)()>(&ns1::other_cls::get_str));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const coid::token&)>(&ns1::other_cls::set_str));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(int&,iref<ns::other>&,int*)>(&ns1::other_cls::some_fun1));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[3];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        return _vtable2;
    }

protected:

    COIDNEWDELETE("ns::other_dispatcher");

    other_dispatcher()
    {}

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in other capture dispatcher");
        }
    }

    static iref<other> _generic_interface_creator(ns1::other_cls* host, other* __here__)
    {
        //cast to dispatch to sidestep protected access restrictions
        other_dispatcher* __disp__ = static_cast<other_dispatcher*>(__here__);
        if (!__disp__)
            __disp__ = new other_dispatcher;

        __disp__->_host.create(host);
        __disp__->_vtable = _capture ? get_vtable_intercept() : get_vtable();

        return __disp__;
    }

public:

    // creator methods

    static iref<other> create( other* __here__, const coid::charstr& str )
    {
        iref<ns1::other_cls> __host__ = ns1::other_cls::create(str);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
        interface_register::register_interface_creator(
            "ns::other@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

        interface_register::register_interface_creator(
            "ns::other.create@4072607744",
            on ? (void*)&create : nullptr);
    }
};

coid::binstring* other_dispatcher::_capture = 0;
uint16 other_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* other_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* other_dispatcher::_vtable1 = 0;


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) other_autoregger = new ifc_autoregger(&other_dispatcher::register_interfaces);

void* force_register_other() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&other_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ns

static_assert( std::is_base_of<policy_intrusive_base, ns1::main_cls>::value, "class 'main_cls' must be derived from policy_intrusive_base");
static_assert( std::is_base_of<policy_intrusive_base, ns1::main_cls>::value, "class 'main_cls' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface main of class main_cls

namespace ns {

///
class main_dispatcher : public main
{
private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[5];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<iref<ns::other>(policy_intrusive_base::*)(coid::charstr&)>(&ns1::main_cls::some_get));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)()>(&ns1::main_cls::get_a));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(int)>(&ns1::main_cls::set_a));
        _vtable1[3] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(int,const ns1::dummy&,float*,ns1::dummy&,int*,iref<ns::other>&,const coid::charstr&)>(&ns1::main_cls::fun1));
        _vtable1[4] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(int,iref<ns::other>,int&,iref<ns::other>&)>(&ns1::main_cls::fun2));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[5];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        _vtable2[3] = vtable1[3];
        _vtable2[4] = vtable1[4];
        return _vtable2;
    }

protected:

    COIDNEWDELETE("ns::main_dispatcher");

    main_dispatcher()
    {}

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in main capture dispatcher");
        }
    }

    ///Cleanup routine called from ~main()
    static void _cleaner_callback( main* m, intergen_interface* ifc ) {
        ns1::main_cls* host = m->host<ns1::main_cls>();
        if (host) host->_ifc = ifc;
    }

    static iref<main> _generic_interface_creator(ns1::main_cls* host, main* __here__)
    {
        //cast to dispatch to sidestep protected access restrictions
        main_dispatcher* __disp__ = static_cast<main_dispatcher*>(__here__);
        if (!__disp__)
            __disp__ = new main_dispatcher;

        __disp__->_host.create(host);
        __disp__->_vtable = _capture ? get_vtable_intercept() : get_vtable();
        if (!host->_ifc) {
            __disp__->_cleaner = &_cleaner_callback;
            host->_ifc = __disp__;
        }

        return __disp__;
    }

public:

    // creator methods

    static iref<main> create( main* __here__ )
    {
        iref<ns1::main_cls> __host__ = ns1::main_cls::create();
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    static iref<main> create_special( main* __here__, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e = -1 )
    {
        iref<ns1::main_cls> __host__ = ns1::main_cls::create_special(a, b, c, d, e);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    static iref<main> create_wp( main* __here__, int a, int& b, int& c, int d = -1 )
    {
        iref<ns1::main_cls> __host__ = ns1::main_cls::create_wp(a, b, c, d);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
        interface_register::register_interface_creator(
            "ns::main@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

        interface_register::register_interface_creator(
            "ns::main.create@3170672600",
            on ? (void*)&create : nullptr);
        interface_register::register_interface_creator(
            "ns::main.create_special@3170672600",
            on ? (void*)&create_special : nullptr);
        interface_register::register_interface_creator(
            "ns::main.create_wp@3170672600",
            on ? (void*)&create_wp : nullptr);
    }
};

coid::binstring* main_dispatcher::_capture = 0;
uint16 main_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* main_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* main_dispatcher::_vtable1 = 0;


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) main_autoregger = new ifc_autoregger(&main_dispatcher::register_interfaces);

void* force_register_main() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&main_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ns

// events

namespace ns1 {

void main_cls::evt1( int a, ifc_out int* b, ifc_out iref<ns::other>& d )
{
	if (!_ifc) 
        throw coid::exception() << "evt1" << " handler not implemented";
    else
        return _ifc->iface<ns::main>()->evt1(a, b, d);
}

coid::charstr main_cls::evt2( int a, ifc_out int* b, ifc_inout ns1::dummy& c, ifc_out iref<ns::other>& d, iref<ns::other> e )
{
	if (!_ifc) 
        throw coid::exception() << "evt2" << " handler not implemented";
    else
        return _ifc->iface<ns::main>()->evt2(a, b, c, d, e);
}

iref<ns::other> main_cls::evt3( const coid::token& msg )
{
	if (!_ifc) 
        throw coid::exception() << "evt3" << " handler not implemented";
    else
        return _ifc->iface<ns::main>()->evt3(msg);
}

iref<ns::main> main_cls::evt4( int a, iref<ns::other> b, ifc_out int& c, ifc_out iref<ns::other>& d, int e )
{
	if (!_ifc) 
        throw coid::exception() << "evt4" << " handler not implemented";
    else
        return _ifc->iface<ns::main>()->evt4(a, b, c, d, e);
}

} //namespace ns1

