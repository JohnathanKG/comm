
//@file  lua interface dispatcher generated by intergen v5
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_lua_capi.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

#include "ifc/other.lua.h"
#include "ifc/main.lua.h"

using namespace coid;

// forward declarations for used iref arguments
typedef iref<::lua::registry_handle> (*lua_ns_other_create_wrapper_fun)(ns::other*, iref<::lua::registry_handle>);
typedef iref<::lua::registry_handle> (*lua_ns_main_create_wrapper_fun)(ns::main*, iref<::lua::registry_handle>);

////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface other of class other_cls
//
////////////////////////////////////////////////////////////////////////////////

namespace ns {
namespace lua {

////////////////////////////////////////////////////////////////////////////////
class other_lua_dispatcher
    : public ::lua::interface_wrapper_base<ns::other>
{
protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_LUA; }
    static const coid::token& lua_class_name() { static const coid::token _lua_class_name = "ns_other"; return _lua_class_name; };

public:

    iref<::lua::registry_handle> create_interface_object(bool make_weak);

    COIDNEWDELETE("ns::other_lua_dispatcher");

    other_lua_dispatcher()
    {    }

    other_lua_dispatcher(iref<::lua::registry_handle> context, ns::other* orig ) {
        _base.create(orig);
        _vtable = _base->vtable();

        _context->set_state(context->get_state());
        context->get_ref();
        _context->set_ref();

        _host = _base->host<policy_intrusive_base>();
    }

    ~other_lua_dispatcher() {

    }
    
    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    /// expects context table on the top of the stack
    static int register_to_context_other(lua_State * L);

    // --- creators ---

    static iref<other_lua_dispatcher> create(lua_State * L, const ::lua::script_handle& scriptpath, const coid::charstr& str, const coid::token& bindname, iref<::lua::registry_handle>* );

    static int luacreator_create0(lua_State * L, ::lua::interface_context* ifc);

    static int lualog_exc(lua_State * L);
    static int lualog(lua_State * L);
    static int luaquery_interface_exc(lua_State * L);
    static int luaquery_interface(lua_State * L);
    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

    static int lua_get_str0_exc( lua_State * L );
    static int lua_get_str0( lua_State * L );
    static int lua_set_str1_exc( lua_State * L );
    static int lua_set_str1( lua_State * L );
    static int lua_some_fun12_exc( lua_State * L );
    static int lua_some_fun12( lua_State * L );
};

////////////////////////////////////////////////////////////////////////////////
//
//  const coid::charstr& ns::other::get_str()
//
__declspec(noinline) int other_lua_dispatcher::lua_get_str0_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "other.get_str";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "other.get_str";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::other>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::other>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "other.get_str";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

//out params

// invoke
        const coid::charstr& _rval_ = R_->get_str();
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");
        to_lua(_rval_);
    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int other_lua_dispatcher::lua_get_str0( lua_State * L ){
    int res = lua_get_str0_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  void ns::other::set_str( const coid::token& new_str)
//
__declspec(noinline) int other_lua_dispatcher::lua_set_str1_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 1 || args_count > 1) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "other.set_str";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "other.set_str";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::other>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::other>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "other.set_str";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<coid::token>::value, "missing metastream operator 'coid::token'");
            threadcached<coid::token> new_str;
        from_lua(new_str);

//out params

// invoke
        R_->set_str(new_str);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        return 0;    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int other_lua_dispatcher::lua_set_str1( lua_State * L ){
    int res = lua_set_str1_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  void ns::other::some_fun1( int& a, iref<ns::other>& b, int* c)
//
__declspec(noinline) int other_lua_dispatcher::lua_some_fun12_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 2 || args_count > 2) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "other.some_fun1";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "other.some_fun1";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::other>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::other>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "other.some_fun1";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
            threadcached<int> a;
        from_lua(a);

        lua_pushvalue(L, 1 + 2);
        iref<ns::other> b;
        from_lua(b);

//out params
        int c;

// invoke
        R_->some_fun1(a, b, &c);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        const uint _res_count = 3 + 1;
        lua_createtable(L, 0, _res_count);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(a);
        lua_setfield(L, -2, "a");
    
        if (!b.is_empty()){
            lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper =
                reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));

            if (!lua_ns_other_create_wrapper) {
                throw coid::exception("create wrapper not found");
            }
            lua_ns_other_create_wrapper(b.get(), ifc->_context)->get_ref();
        }
        else
            lua_pushnil(L);
        lua_setfield(L, -2, "b");
    
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(c);
        lua_setfield(L, -2, "c");
    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int other_lua_dispatcher::lua_some_fun12( lua_State * L ){
    int res = lua_some_fun12_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int other_lua_dispatcher::lualog_exc( lua_State * L )
{
    try {
        if (lua_gettop(L) == 0)
            return 0;

        const void* inst = 0;

        lua_insert(L, 1);

        if (lua_istable(L, -1) && lua_hasfield(L, -1, ::lua::_lua_cthis_key)) {
            lua_getfield(L, -1, ::lua::_lua_cthis_key);
            if (lua_isuserdata(L, -1)) {
                ns::lua::other_lua_dispatcher* ifc = reinterpret_cast<ns::lua::other_lua_dispatcher*>
                    (*static_cast<size_t*>(lua_touserdata(L, -1)));
                lua_pop(L, 1);

                inst = ifc;
                if (!ifc) {
                    throw coid::exception("Null interface object in log");
                }
            }

            lua_pop(L, 1);
        }

        intergen_interface::ifclog_ext(coid::ELogType::None, coid::tokenhash("ns::other"),
            inst, lua_totoken(L, -1));

        lua_pop(L, 1);

        return 0;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////
int other_lua_dispatcher::lualog(lua_State * L) {
    int res = lualog_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int other_lua_dispatcher::luaquery_interface_exc( lua_State * L )
{
    try {

        if (lua_gettop(L) < 2) {
            throw coid::exception("Interface creator name or caller object is missing.");
        }
        
        lua_pushbot(L); // move object table onto top of the stack

        if (!lua_istable(L, -1) || !lua_hasfield(L,-1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);

        if (!lua_isuserdata(L,-1))
            return 0;

        ns::lua::other_lua_dispatcher* ifc = reinterpret_cast<ns::lua::other_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        if (!ifc)
            throw coid::exception("Null interface object in query_interface");

        lua_pushbot(L); // move creator key onto top of the stack

        if (!lua_isstring(L, -1))
            throw coid::exception("Interface creator name missing.");

        coid::token tokey = lua_totoken(L, -1);

        typedef int(*fn_get)(lua_State * L, ::lua::interface_context*);
        fn_get get = reinterpret_cast<fn_get>(
            coid::interface_register::get_interface_creator(tokey));

        if (!get) {
            coid::charstr tmp = "interface creator ";
            tmp << tokey << " not found";
            throw coid::exception(tmp);
        }

        lua_pop(L, 3); // pop redundant data from stack

        get(L, ifc);
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int other_lua_dispatcher::luaquery_interface(lua_State * L) {
    int res = luaquery_interface_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int other_lua_dispatcher::luarebind_events_exc( lua_State * L )
{
    return 0;
}

int other_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> other_lua_dispatcher::create_interface_object( bool make_weak )
{
    lua_State * L = _context->get_state();
    _context->get_ref();
    if (!lua_hasfield(L, -1, lua_class_name()))
    {
        register_to_context_other(L);
    }
    lua_pop(L, 1);

    lua_createtable(L, 0, 3);
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_cthis_key);
        
    lua_pushnumber(L, ints(4122940601));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);

    _context->get_ref();
    lua_getfield(L, -1, lua_class_name());
    lua_setfield(L, -3, ::lua::_lua_parent_index_key);
    lua_pop(L, 1);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_MT_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();
    return obj;
}


// --- registrar ---
int other_lua_dispatcher::register_to_context_other(lua_State * L) {
    //lua_getglobal(L, ::lua::_lua_class_register_key);

   // if (lua_isnil(L, -1)) {
   //     throw coid::exception() << "Given lua_State is not valid!(use lua_state_wrapper to create valid lua_State)";
  //  }

    //const uint methods_count =3 

    lua_createtable(L, 0, 0);

    lua_pushcfunction(L, &other_lua_dispatcher::lualog);
    lua_setfield(L, -2, ::lua::_lua_log_key);

    lua_pushcfunction(L, &other_lua_dispatcher::luaquery_interface);
    lua_setfield(L, -2, ::lua::_lua_query_interface_key);

    lua_pushcfunction(L, &other_lua_dispatcher::lua_get_str0);
    lua_setfield(L, -2, "get_str");

    lua_pushcfunction(L, &other_lua_dispatcher::lua_set_str1);
    lua_setfield(L, -2, "set_str");

    lua_pushcfunction(L, &other_lua_dispatcher::lua_some_fun12);
    lua_setfield(L, -2, "some_fun1");

    lua_setfield(L, -2, lua_class_name());
    
    return 0;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<other_lua_dispatcher> other_lua_dispatcher::create(lua_State * L, const ::lua::script_handle& script, const coid::charstr& str, const coid::token& bindname, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<other_lua_dispatcher> ifc = ns::other::create(new other_lua_dispatcher, str);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }
    
    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

    if (bindname) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bindname);
        lua_pop(L, 1);
    }
    
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<ns::other> ns::other::create( const coid::charstr& str)
///

int other_lua_dispatcher::luacreator_create0(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < 1 || args_count > 1) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "other.create";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    lua_pushvalue(L, 0 + 1);
    static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator 'coid::charstr'");
    threadcached<coid::charstr> str;
    from_lua(str);

//out params
    iref<other_lua_dispatcher> nifc = ns::other::create(new other_lua_dispatcher, str);

    //stream out
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_other(::ns::other* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<ns::lua::other_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_LUA)
        obj = static_cast<other_lua_dispatcher*>(orig)->_object;
    
    if (obj.is_empty()) {
        // create interface object
        ifc.create(new ns::lua::other_lua_dispatcher(context, static_cast<::ns::other*>(orig)));

        obj = ifc->create_interface_object(true);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_other( bool on )
{
    interface_register::register_interface_creator(
        "lua::register_class.ns_other",
        on ? (void*)&other_lua_dispatcher::register_to_context_other
        : nullptr);

    interface_register::register_interface_creator(
        "ns::lua::other.create@creator",
        on ? (void*)&other_lua_dispatcher::create : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::other.create",
        on ? (void*)&other_lua_dispatcher::luacreator_create0 : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::other@wrapper",
        on ? (void*)&create_wrapper_other : nullptr);

}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) other_autoregger = new ifc_autoregger(&register_binders_for_other);

void* force_register_other() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_other);
    return autoregger.get();
}

} //namespace lua
} //namespace ns

////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface main of class main_cls
//
////////////////////////////////////////////////////////////////////////////////

namespace ns {
namespace lua {

////////////////////////////////////////////////////////////////////////////////
class main_lua_dispatcher
    : public ::lua::interface_wrapper_base<ns::main>
{
    iref<::lua::weak_registry_handle> _events[4];
    
    void init_event_registry() {
        for (int i = 0; i < 4; i++) {
            _events[i] = new ::lua::weak_registry_handle;
        }
    }
    bool _bound_events;

protected:

    EBackend intergen_backend() const override { return IFC_BACKEND_LUA; }
    static const coid::token& lua_class_name() { static const coid::token _lua_class_name = "ns_main"; return _lua_class_name; };

public:

    iref<::lua::registry_handle> create_interface_object(bool make_weak);
    void bind_events( bool force, iref<::lua::registry_handle> ref );

    COIDNEWDELETE("ns::main_lua_dispatcher");

    main_lua_dispatcher() : _bound_events(false)
    {
        init_event_registry();
    }

    main_lua_dispatcher(iref<::lua::registry_handle> context, ns::main* orig ) : _bound_events(false) {
        _base.create(orig);
        _vtable = _base->vtable();

        _context->set_state(context->get_state());
        context->get_ref();
        _context->set_ref();

        _host = _base->host<policy_intrusive_base>();

        init_event_registry();
    }

    ~main_lua_dispatcher() {

    }
    
    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    /// expects context table on the top of the stack
    static int register_to_context_main(lua_State * L);

    // --- creators ---

    static iref<main_lua_dispatcher> create(lua_State * L, const ::lua::script_handle& scriptpath, const coid::token& bindname, iref<::lua::registry_handle>* );

    static int luacreator_create0(lua_State * L, ::lua::interface_context* ifc);
    static iref<main_lua_dispatcher> create_special(lua_State * L, const ::lua::script_handle& scriptpath, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e, const coid::token& bindname, iref<::lua::registry_handle>* );

    static int luacreator_create_special1(lua_State * L, ::lua::interface_context* ifc);
    static iref<main_lua_dispatcher> create_wp(lua_State * L, const ::lua::script_handle& scriptpath, int a, int& b, int& c, int d, const coid::token& bindname, iref<::lua::registry_handle>* );

    static int luacreator_create_wp2(lua_State * L, ::lua::interface_context* ifc);

    static int lualog_exc(lua_State * L);
    static int lualog(lua_State * L);
    static int luaquery_interface_exc(lua_State * L);
    static int luaquery_interface(lua_State * L);
    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

    static int lua_some_get0_exc( lua_State * L );
    static int lua_some_get0( lua_State * L );
    static int lua_get_a1_exc( lua_State * L );
    static int lua_get_a1( lua_State * L );
    static int lua_set_a2_exc( lua_State * L );
    static int lua_set_a2( lua_State * L );
    static int lua_fun13_exc( lua_State * L );
    static int lua_fun13( lua_State * L );
    static int lua_fun24_exc( lua_State * L );
    static int lua_fun24( lua_State * L );

    // --- interface events ---

    virtual void evt1( int a, int* b, iref<ns::other>& d ) override;
    virtual coid::charstr evt2( int a, int* b, ns1::dummy& c, iref<ns::other>& d, iref<ns::other> e ) override;
    virtual iref<ns::other> evt3( const coid::token& msg ) override;
    virtual iref<ns::main> evt4( int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e = -1 ) override;

    virtual bool is_bound_evt1() override { return is_event_bound(0); }
    virtual bool is_bound_evt2() override { return is_event_bound(1); }
    virtual bool is_bound_evt3() override { return is_event_bound(2); }
    virtual bool is_bound_evt4() override { return is_event_bound(3); }

virtual void force_bind_script_events() {
    bind_events( true, iref<::lua::registry_handle>(&::lua::registry_handle()));
}

private:
    bool is_event_bound(int id)
    {
        if (!_bound_events) {
            bind_events( false, iref<::lua::registry_handle>(&::lua::registry_handle()));
        }

        return !_events[id];
    }

    //event wrappers for event invocation from lua
    static int lua_evback_evt10( lua_State * L );
    static int lua_evback_evt21( lua_State * L );
    static int lua_evback_evt32( lua_State * L );
    static int lua_evback_evt43( lua_State * L );
};

////////////////////////////////////////////////////////////////////////////////
//
//  iref<ns::other> ns::main::some_get( coid::charstr& a)
//
__declspec(noinline) int main_lua_dispatcher::lua_some_get0_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "main.some_get";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "main.some_get";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::main>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::main>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "main.some_get";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

//out params
        coid::charstr a;

// invoke
        iref<ns::other> _rval_ = R_->some_get(a);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        const uint _res_count = 1 + 1;
        lua_createtable(L,0,_res_count);
        if (!_rval_.is_empty()){
            lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper =
                reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));

            if (!lua_ns_other_create_wrapper) {
                throw coid::exception("create wrapper not found");
            }
            lua_ns_other_create_wrapper(_rval_.get(), ifc->_context)->get_ref();
        }
        else
            lua_pushnil(L);
        lua_setfield(L, -2, "_ret");
    
        static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");
        to_lua(a);
        lua_setfield(L, -2, "a");

    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::lua_some_get0( lua_State * L ){
    int res = lua_some_get0_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  int ns::main::get_a()
//
__declspec(noinline) int main_lua_dispatcher::lua_get_a1_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "main.get_a";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "main.get_a";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::main>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::main>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "main.get_a";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

//out params

// invoke
        int _rval_ = R_->get_a();
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(_rval_);
    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::lua_get_a1( lua_State * L ){
    int res = lua_get_a1_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  void ns::main::set_a( int a)
//
__declspec(noinline) int main_lua_dispatcher::lua_set_a2_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 1 || args_count > 1) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "main.set_a";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "main.set_a";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::main>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::main>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "main.set_a";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
            threadcached<int> a;
        from_lua(a);

//out params

// invoke
        R_->set_a(a);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        return 0;    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::lua_set_a2( lua_State * L ){
    int res = lua_set_a2_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  void ns::main::fun1( int a, const ns1::dummy& b, float* c, ns1::dummy& d, int* e, iref<ns::other>& f, const coid::charstr& g)
//
__declspec(noinline) int main_lua_dispatcher::lua_fun13_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 4 || args_count > 4) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "main.fun1";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "main.fun1";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::main>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::main>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "main.fun1";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
            threadcached<int> a;
        from_lua(a);

        lua_pushvalue(L, 1 + 2);
        static_assert(CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator 'ns1::dummy'");
            threadcached<ns1::dummy> b;
        from_lua(b);

        lua_pushvalue(L, 2 + 2);
        static_assert(CHECK::meta_operator_exists<float>::value, "missing metastream operator 'float'");
            threadcached<float> c;
        from_lua(c);

        lua_pushvalue(L, 3 + 2);
        static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator 'coid::charstr'");
            threadcached<coid::charstr> g;
        from_lua(g);

//out params
        ns1::dummy d;
        int e;
        iref<ns::other> f;

// invoke
        R_->fun1(a, b, &c, d, &e, f, g);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        const uint _res_count = 3 + 1;
        lua_createtable(L, 0, _res_count);
        static_assert(CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'");
        to_lua(d);
        lua_setfield(L, -2, "d");
    
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(e);
        lua_setfield(L, -2, "e");
    
        if (!f.is_empty()){
            lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper =
                reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));

            if (!lua_ns_other_create_wrapper) {
                throw coid::exception("create wrapper not found");
            }
            lua_ns_other_create_wrapper(f.get(), ifc->_context)->get_ref();
        }
        else
            lua_pushnil(L);
        lua_setfield(L, -2, "f");
    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::lua_fun13( lua_State * L ){
    int res = lua_fun13_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
//
//  coid::charstr ns::main::fun2( int a, iref<ns::other> b, int& c, iref<ns::other>& d)
//
__declspec(noinline) int main_lua_dispatcher::lua_fun24_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 2 || args_count > 2) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "main.fun2";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "main.fun2";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<ns::main>* ifc = reinterpret_cast<::lua::interface_wrapper_base<ns::main>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "main.fun2";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in

        lua_pushvalue(L, 0 + 2);
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
            threadcached<int> a;
        from_lua(a);

        lua_pushvalue(L, 1 + 2);
        iref<ns::other> b;
        from_lua(b);

//out params
        int c;
        iref<ns::other> d;

// invoke
        coid::charstr _rval_ = R_->fun2(a, b, c, d);
    
//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        const uint _res_count = 2 + 1;
        lua_createtable(L,0,_res_count);
        static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");
        to_lua(_rval_);
        lua_setfield(L, -2, "_ret");
    
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(c);
        lua_setfield(L, -2, "c");

    
        if (!d.is_empty()){
            lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper =
                reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));

            if (!lua_ns_other_create_wrapper) {
                throw coid::exception("create wrapper not found");
            }

            lua_ns_other_create_wrapper(d.get(), ifc->_context)->get_ref();
        }
        else
            lua_pushnil(L);
        lua_setfield(L, -2, "d");

    
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::lua_fun24( lua_State * L ){
    int res = lua_fun24_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
void main_lua_dispatcher::evt1( int a, int* b, iref<ns::other>& d )
{
    bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[0];

    if (ev__->is_empty())
        throw coid::exception("handler not implemented");

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );

// stream in args and lua function for event call
    ev__->get_ref();
    _object->get_ref();


    lua_streamer<int>::to_lua(a); // TODO: volatile streamers

    const uint nres = 1;

// call event
    int res = lua_pcall(L,1 + 1,nres,0);

    if (res != 0) {
        ::lua::throw_lua_error(L, "ns::lua::main.evt1(): ");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    if (!lua_istable(L,-1)) throw coid::exception("invalid params");

    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    
    lua_getfield(L,-1,"b");
    if (b)
        from_lua(*b);
    
    lua_getfield(L,-1,"d");
    from_lua(d);
}

////////////////////////////////////////////////////////////////////////////////
coid::charstr main_lua_dispatcher::evt2( int a, int* b, ns1::dummy& c, iref<ns::other>& d, iref<ns::other> e )
{
    bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[1];

    if (ev__->is_empty())
        throw coid::exception("handler not implemented");

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    static_assert( CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'" );

// stream in args and lua function for event call
    ev__->get_ref();
    _object->get_ref();


    lua_streamer<int>::to_lua(a); // TODO: volatile streamers
    lua_streamer<ns1::dummy>::to_lua(c); // TODO: volatile streamers
    lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper = 
        reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));
    
    if(!lua_ns_other_create_wrapper){
        throw coid::exception("create wrapper not found");
    }

    if (!e.is_empty()) {
        lua_ns_other_create_wrapper(e.get(), _context)->get_ref();
    }
    else {
        lua_pushnil(L);
    }

    const uint nres = 1;

// call event
    int res = lua_pcall(L,3 + 1,nres,0);

    if (res != 0) {
        ::lua::throw_lua_error(L, "ns::lua::main.evt2(): ");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    if (!lua_istable(L,-1)) throw coid::exception("invalid params");

    static_assert(CHECK::meta_operator_exists<coid::charstr>::value, "missing metastream operator for 'coid::charstr'");
    threadcached<coid::charstr> _rval_;
    lua_getfield(L, -1, "_ret");
    from_lua(_rval_);
        
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    static_assert( CHECK::meta_operator_exists<ns1::dummy>::value, "missing metastream operator for 'ns1::dummy'" );
    
    lua_getfield(L,-1,"b");
    if (b)
        from_lua(*b);
    
    lua_getfield(L,-1,"c");
    from_lua(c);
    
    lua_getfield(L,-1,"d");
    from_lua(d);
    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
iref<ns::other> main_lua_dispatcher::evt3( const coid::token& msg )
{
    bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[2];

    if (ev__->is_empty())
        throw coid::exception("handler not implemented");

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert( CHECK::meta_operator_exists<coid::token>::value, "missing metastream operator for 'coid::token'" );

// stream in args and lua function for event call
    ev__->get_ref();
    _object->get_ref();


    lua_streamer<coid::token>::to_lua(msg); // TODO: volatile streamers

    const uint nres = 1;

// call event
    int res = lua_pcall(L,1 + 1,nres,0);

    if (res != 0) {
        ::lua::throw_lua_error(L, "ns::lua::main.evt3(): ");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    static_assert(CHECK::meta_operator_exists<iref<ns::other>>::value, "missing metastream operator for 'iref<ns::other>'");
    threadcached<iref<ns::other>> _rval_;
    from_lua(_rval_);
    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
iref<ns::main> main_lua_dispatcher::evt4( int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e )
{
    bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[3];

    if (ev__->is_empty())
        throw coid::exception("handler not implemented");

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );

// stream in args and lua function for event call
    ev__->get_ref();
    _object->get_ref();


    lua_streamer<int>::to_lua(a); // TODO: volatile streamers
    lua_ns_other_create_wrapper_fun lua_ns_other_create_wrapper = 
        reinterpret_cast<lua_ns_other_create_wrapper_fun>(get_cached_create_wrapper_fun<ns::other, EBackend::IFC_BACKEND_LUA>("ns::lua::other@wrapper"));
    
    if(!lua_ns_other_create_wrapper){
        throw coid::exception("create wrapper not found");
    }

    if (!b.is_empty()) {
        lua_ns_other_create_wrapper(b.get(), _context)->get_ref();
    }
    else {
        lua_pushnil(L);
    }
    lua_streamer<int>::to_lua(e); // TODO: volatile streamers

    const uint nres = 1;

// call event
    int res = lua_pcall(L,3 + 1,nres,0);

    if (res != 0) {
        ::lua::throw_lua_error(L, "ns::lua::main.evt4(): ");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    if (!lua_istable(L,-1)) throw coid::exception("invalid params");

    static_assert(CHECK::meta_operator_exists<iref<ns::main>>::value, "missing metastream operator for 'iref<ns::main>'");
    threadcached<iref<ns::main>> _rval_;
    lua_getfield(L, -1, "_ret");
    from_lua(_rval_);
        
    static_assert( CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'" );
    
    lua_getfield(L,-1,"c");
    from_lua(c);
    
    lua_getfield(L,-1,"d");
    from_lua(d);
    return _rval_;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int main_lua_dispatcher::lualog_exc( lua_State * L )
{
    try {
        if (lua_gettop(L) == 0)
            return 0;

        const void* inst = 0;

        lua_insert(L, 1);

        if (lua_istable(L, -1) && lua_hasfield(L, -1, ::lua::_lua_cthis_key)) {
            lua_getfield(L, -1, ::lua::_lua_cthis_key);
            if (lua_isuserdata(L, -1)) {
                ns::lua::main_lua_dispatcher* ifc = reinterpret_cast<ns::lua::main_lua_dispatcher*>
                    (*static_cast<size_t*>(lua_touserdata(L, -1)));
                lua_pop(L, 1);

                inst = ifc;
                if (!ifc) {
                    throw coid::exception("Null interface object in log");
                }
            }

            lua_pop(L, 1);
        }

        intergen_interface::ifclog_ext(coid::ELogType::None, coid::tokenhash("ns::main"),
            inst, lua_totoken(L, -1));

        lua_pop(L, 1);

        return 0;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////
int main_lua_dispatcher::lualog(lua_State * L) {
    int res = lualog_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int main_lua_dispatcher::luaquery_interface_exc( lua_State * L )
{
    try {

        if (lua_gettop(L) < 2) {
            throw coid::exception("Interface creator name or caller object is missing.");
        }
        
        lua_pushbot(L); // move object table onto top of the stack

        if (!lua_istable(L, -1) || !lua_hasfield(L,-1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);

        if (!lua_isuserdata(L,-1))
            return 0;

        ns::lua::main_lua_dispatcher* ifc = reinterpret_cast<ns::lua::main_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        if (!ifc)
            throw coid::exception("Null interface object in query_interface");

        lua_pushbot(L); // move creator key onto top of the stack

        if (!lua_isstring(L, -1))
            throw coid::exception("Interface creator name missing.");

        coid::token tokey = lua_totoken(L, -1);

        typedef int(*fn_get)(lua_State * L, ::lua::interface_context*);
        fn_get get = reinterpret_cast<fn_get>(
            coid::interface_register::get_interface_creator(tokey));

        if (!get) {
            coid::charstr tmp = "interface creator ";
            tmp << tokey << " not found";
            throw coid::exception(tmp);
        }

        lua_pop(L, 3); // pop redundant data from stack

        get(L, ifc);
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::luaquery_interface(lua_State * L) {
    int res = luaquery_interface_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int main_lua_dispatcher::luarebind_events_exc( lua_State * L )
{
    try {
        lua_pushbot(L);
        if (!lua_istable(L,-1) || !lua_hasfield(L, -1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        if (!lua_isuserdata(L,-1))
            return 0;

        ns::lua::main_lua_dispatcher* ifc = reinterpret_cast<ns::lua::main_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        lua_pop(L, 1);

        if (ifc) {
            iref<::lua::registry_handle> val;
            if (lua_gettop(L) > 0)
                val->set_ref();
            ifc->bind_events(true, val);
         }
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int main_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> main_lua_dispatcher::create_interface_object( bool make_weak )
{
    lua_State * L = _context->get_state();
    _context->get_ref();
    if (!lua_hasfield(L, -1, lua_class_name()))
    {
        register_to_context_main(L);
    }
    lua_pop(L, 1);

    lua_createtable(L, 0, 3);
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_cthis_key);
        
    lua_pushnumber(L, ints(3221005457));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);

    _context->get_ref();
    lua_getfield(L, -1, lua_class_name());
    lua_setfield(L, -3, ::lua::_lua_parent_index_key);
    lua_pop(L, 1);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_MT_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();
    return obj;
}

////////////////////////////////////////////////////////////////////////////////
void main_lua_dispatcher::bind_events(bool force, iref<::lua::registry_handle> ref )
{
    if (!force && _bound_events)
        return;

    static token names[] = {
        "evt1",
        "evt2",
        "evt3",
        "evt4",
    };

    lua_State * L = nullptr;
    bool clear = false;

    if (ref.is_empty()) { // nullptr
        clear = true;
    }
    else if (ref->is_empty()) { // ref handle is not holding any object
        L = _context->get_state();
        _context->get_ref();
        lua_getfield(L, -1, lua_class_name());
        lua_insert(L, -2);
        lua_pop(L, 1);
    }
    else {
        L = ref->get_state();
        ref->get_ref();
        lua_getfield(L, -1, ::lua::_lua_parent_index_key);
        lua_insert(L, -2);
        lua_pop(L, 1);
    }

    for (int i = 0; i<4; ++i)
    {
        _events[i]->release();

        if (clear) {
            continue;
        }
        _events[i]->set_state(L);
        lua_getfield(L, -1, names[i]);
        if (!lua_isfunction(L, -1)) {
            lua_pop(L, 1);
            continue;
        }

        _events[i]->set_ref();
    }

    lua_pop(L, 1);

    _bound_events = true;
}


// --- registrar ---
int main_lua_dispatcher::register_to_context_main(lua_State * L) {
    //lua_getglobal(L, ::lua::_lua_class_register_key);

   // if (lua_isnil(L, -1)) {
   //     throw coid::exception() << "Given lua_State is not valid!(use lua_state_wrapper to create valid lua_State)";
  //  }

    //const uint methods_count =5 

    lua_createtable(L, 0, 0);

    lua_pushcfunction(L, &main_lua_dispatcher::lualog);
    lua_setfield(L, -2, ::lua::_lua_log_key);

    lua_pushcfunction(L, &main_lua_dispatcher::luaquery_interface);
    lua_setfield(L, -2, ::lua::_lua_query_interface_key);

    lua_pushcfunction(L, &main_lua_dispatcher::lua_some_get0);
    lua_setfield(L, -2, "some_get");

    lua_pushcfunction(L, &main_lua_dispatcher::lua_get_a1);
    lua_setfield(L, -2, "get_a");

    lua_pushcfunction(L, &main_lua_dispatcher::lua_set_a2);
    lua_setfield(L, -2, "set_a");

    lua_pushcfunction(L, &main_lua_dispatcher::lua_fun13);
    lua_setfield(L, -2, "fun1");

    lua_pushcfunction(L, &main_lua_dispatcher::lua_fun24);
    lua_setfield(L, -2, "fun2");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "evt1");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "evt2");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "evt3");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "evt4");

    lua_setfield(L, -2, lua_class_name());
    
    return 0;
}

// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<main_lua_dispatcher> main_lua_dispatcher::create(lua_State * L, const ::lua::script_handle& script, const coid::token& bindname, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<main_lua_dispatcher> ifc = ns::main::create(new main_lua_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }
    
    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

    if (bindname) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bindname);
        lua_pop(L, 1);
    }
    
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<ns::main> ns::main::create()
///

int main_lua_dispatcher::luacreator_create0(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < 0 || args_count > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.create";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

//out params
    iref<main_lua_dispatcher> nifc = ns::main::create(new main_lua_dispatcher);

    //stream out
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
iref<main_lua_dispatcher> main_lua_dispatcher::create_special(lua_State * L, const ::lua::script_handle& script, int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e, const coid::token& bindname, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<main_lua_dispatcher> ifc = ns::main::create_special(new main_lua_dispatcher, a, b, c, d, e);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }
    
    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

    if (bindname) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bindname);
        lua_pop(L, 1);
    }
    
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<ns::main> ns::main::create_special( int a, iref<ns::other> b, int& c, iref<ns::other>& d, int e)
///

int main_lua_dispatcher::luacreator_create_special1(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < 2 || args_count > 3) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.create_special";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    lua_pushvalue(L, 0 + 1);
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
    threadcached<int> a;
    from_lua(a);

    lua_pushvalue(L, 1 + 1);
        iref<ns::other> b;
    from_lua(b);

    lua_pushvalue(L, 2 + 1);
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
    threadcached<int> e;
    if (2 < args_count)
        from_lua(e);
    else
        e = -1;

//out params
    int c;

    iref<ns::other> d;

    iref<main_lua_dispatcher> nifc = ns::main::create_special(new main_lua_dispatcher, a, b, c, d, e);

    //stream out
    lua_createtable(L, 0, 2 + 1);
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }
    
    lua_setfield(L, -2, "ret");

        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(c);
        lua_setfield(L, -2, "c");
    
        to_lua(d);
        lua_setfield(L, -2, "d");
    

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
iref<main_lua_dispatcher> main_lua_dispatcher::create_wp(lua_State * L, const ::lua::script_handle& script, int a, int& b, int& c, int d, const coid::token& bindname, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<main_lua_dispatcher> ifc = ns::main::create_wp(new main_lua_dispatcher, a, b, c, d);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }
    
    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

    if (bindname) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bindname);
        lua_pop(L, 1);
    }
    
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<ns::main> ns::main::create_wp( int a, int& b, int& c, int d)
///

int main_lua_dispatcher::luacreator_create_wp2(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < 2 || args_count > 3) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "main.create_wp";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    lua_pushvalue(L, 0 + 1);
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
    threadcached<int> a;
    from_lua(a);

    lua_pushvalue(L, 1 + 1);
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
    threadcached<int> b;
    from_lua(b);

    lua_pushvalue(L, 2 + 1);
    static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator 'int'");
    threadcached<int> d;
    if (2 < args_count)
        from_lua(d);
    else
        d = -1;

//out params
    int c;

    iref<main_lua_dispatcher> nifc = ns::main::create_wp(new main_lua_dispatcher, a, b, c, d);

    //stream out
    lua_createtable(L, 0, 2 + 1);
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }
    
    lua_setfield(L, -2, "ret");

        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(b);
        lua_setfield(L, -2, "b");
    
        static_assert(CHECK::meta_operator_exists<int>::value, "missing metastream operator for 'int'");
        to_lua(c);
        lua_setfield(L, -2, "c");
    

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_main(::ns::main* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<ns::lua::main_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::IFC_BACKEND_LUA)
        obj = static_cast<main_lua_dispatcher*>(orig)->_object;
    
    if (obj.is_empty()) {
        // create interface object
        ifc.create(new ns::lua::main_lua_dispatcher(context, static_cast<::ns::main*>(orig)));

        obj = ifc->create_interface_object(true);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_main( bool on )
{
    interface_register::register_interface_creator(
        "lua::register_class.ns_main",
        on ? (void*)&main_lua_dispatcher::register_to_context_main
        : nullptr);

    interface_register::register_interface_creator(
        "ns::lua::main.create@creator",
        on ? (void*)&main_lua_dispatcher::create : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main.create",
        on ? (void*)&main_lua_dispatcher::luacreator_create0 : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main.create_special@creator",
        on ? (void*)&main_lua_dispatcher::create_special : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main.create_special",
        on ? (void*)&main_lua_dispatcher::luacreator_create_special1 : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main.create_wp@creator",
        on ? (void*)&main_lua_dispatcher::create_wp : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main.create_wp",
        on ? (void*)&main_lua_dispatcher::luacreator_create_wp2 : nullptr);
    interface_register::register_interface_creator(
        "ns::lua::main@wrapper",
        on ? (void*)&create_wrapper_main : nullptr);

}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) main_autoregger = new ifc_autoregger(&register_binders_for_main);

void* force_register_main() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_main);
    return autoregger.get();
}

} //namespace lua
} //namespace ns

