
//@file $name$ javascript interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>


$-[class]$$[iface]$
#include "$relpathjsc$"
$-[/iface]$$[/class]$

using namespace coid;

$-[class]$$[iface rest="\n\n"]$
////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface $name$ of class $..class$
//
////////////////////////////////////////////////////////////////////////////////

$-[ns]$
namespace $@value$ {
$-[/ns]$
namespace js {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_js_dispatcher
    : public ::jsc::interface_wrapper_base<$ns rest="::"$::$name$>
{
    bool _own_context = false;
    bool _is_weak = false;
$-(if event?)$
    mutable JSObjectRef _events[$event.@size$];
    mutable bool _bound_events;

$-(/if)$

$-(if hasprops?)$
    static JSValueRef _getter(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);
    static bool _setter(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception);
$-(/if)$
    static void _finalizer(JSObjectRef obj)
    {
        jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(obj));
        $name$_js_dispatcher* ifc = static_cast<$name$_js_dispatcher*>(p->that);
        if(ifc->_is_weak) {
            jsc::jsc_queue_finalize(p, [](void* ptr){
                $name$_js_dispatcher* ifc = static_cast<$name$_js_dispatcher*>(ptr);
                ifc->_object = nullptr;
                ifc->release_refcount();
            });
        }
        delete p;
    }
protected:

    backend intergen_backend() const override { return backend::js; }

public:

    JSObjectRef create_interface_object( JSContextRef context, bool make_weak );

    static void load_script( const coid::token& scriptfile, const coid::token& file_name, JSContextRef ctx);
$-(if event?)$
    void bind_events( JSContextRef context, bool force, JSValueRef ref ) const;
$-(/if)$

    COIDNEWDELETE("$[ns]$$@value$::$[/ns]$$name$_js_dispatcher");

    $name$_js_dispatcher() $-(if event?)$ : _bound_events(false)$(/if)$
    {}

    explicit $name$_js_dispatcher( $ns rest="::" after="::"$$name$* orig ) $(if event?)$: _bound_events(false) $(/if)${
        _base.create(orig);
        _vtable = _base->vtable();
        _host = _base->host<policy_intrusive_base>();
    }

    void set_host( policy_intrusive_base* host ) {
        _host = host;
    }

    ~$name$_js_dispatcher() {
$-(if event?)$
        for (int i=0; i<$event.@size$; ++i) {
            if (_events[i]) JSValueUnprotect(_context, _events[i]);
            _events[i] = nullptr;
        }

$-(/if)$
        if (!_is_weak && _object) {
            JSValueUnprotect(_context, _object);
        }
        if (_own_context) {
            JSGlobalContextRelease(JSContextGetGlobalContext(_context));
        }
        _object = nullptr;
        _context = nullptr;
    }

    bool is_weak() const { return _is_weak; }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

$-[method static? !ifccr?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_js_dispatcher> $name$( const jsc::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, JSContextRef* );

    $-(if !internal?)$
    static JSValueRef jsc_creator_$name$$@order$(JSContextRef ctx, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], interface_context* ifc, JSValueRef* exception);

    $-(/if)$
$-[/method]$
    ///Handler for generic $$query_interface javascript method
    static JSValueRef jsc_query_interface(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_query_interface_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_log(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_rebind_events(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
    static JSValueRef jsc_current_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);

    // --- method wrappers ---

$-[method !static? !destroy? !internal? !operator?]$
    static JSValueRef jsc_$name$$@index$(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
$-[/method]$
$-(if event.empty!)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) $-(if const?)$ const$(/if)$ override;
$-[/event]$

$-[event]$
    virtual bool is_bound_$name$() override { return is_event_bound($@index$); }
$-[/event]$

    virtual void force_bind_script_events() {
        bind_events(_context, true, JSValueMakeUndefined(_context));
    }

private:
    bool is_event_bound( int id )
    {
        if (!_bound_events) {
            bind_events(_context, false, JSValueMakeUndefined(_context));
        }

        return _events[id] && !JSValueIsUndefined(_context, _events[id]);
    }

    //event wrappers for event invocation from js
$-[event]$
    static JSValueRef jsc_evback_$name$$@index$(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);
$-[/event]$
$-(/if)$
};


$-[method !static? !destroy? !internal? !operator?]$
////////////////////////////////////////////////////////////////////////////////
JSValueRef $..name$_js_dispatcher::jsc_$name$$@index$(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < $ninargs_nondef$ || argumentCount > $ninargs$) { //in/inout arguments
        const char* tmp = "Wrong number of arguments in $..name$.$name$";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* p = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!p)
        return JSValueMakeUndefined(ctx);

    ::jsc::interface_wrapper_base<$..ns rest="::"$::$..name$>* ifc = static_cast<::jsc::interface_wrapper_base<$..ns rest="::"$::$..name$>*>
        (p->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in $..name$.$name$";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    try {
        //stream the arguments in
$-[args inarg? !nojs?]$
 $-(if iref.false?)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator '$basetype$'");
 $-(/if)$
$-[/args]$

$-[args inarg? !nojs?]$
  $-(if !defval.empty? ptr.true?)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$ *$name$ = &$name$__tmp;
        if ($@order$ < args.Length())
            write_from_jsc(ctx, arguments[$@order$], $name$__tmp);
        else
            $name$ = $defval$;
  $-(elif !defval.empty?)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args.Length())
            write_from_jsc(ctx, arguments[$@order$], $name$);
        else
            $name$ = $defval$;
  $-(elif)$
        threadcached<$basetype$> $name$;
        write_from_jsc(ctx, arguments[$@order$], $name$);
  $-(/if)$
$[/args]-$

        //invoke
$-[args outarg? !inarg?]$
        $basetype$ $name$;
$[/args]-$

        $(if return.type!="void")$$return.type$ _rval_ = $(/if)$R_->$name$($[args rest=", "]$ $-(if ptr? outarg?)$&$-(elif ptr? defval.empty? !specptr?)$&$(/if)$ $-(if nojs?)$$defval$$(elif)$$name$$(/if)$$[/args]$);

        //stream out
$-(if return.type!="void")$
 $-(if return.iref.false? noutargs?)$
        static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
        JSObjectRef r__ = JSObjectMake(ctx, nullptr, nullptr);
        jsc::set_property(ctx, r__, "$$ret", read_to_jsc(ctx, _rval_));
 $-(elif noutargs?)$
        JSObjectRef r__ = JSObjectMake(ctx, nullptr, nullptr);;
        set_proprety(ctx, r__, "$$ret", ::jsc::wrap_object(_rval_.get(), ifc->_context));
 $-(elif return.iref.false?)$
        JSValueRef r__ = nullptr;
  $-(if return.ptr.true?)$
        static_assert( CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'" );
        if (_rval_)
            r__ = read_to_jsc(ctx, *_rval_);
  $-(elif)$
        static_assert( CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'" );
        r__ = read_to_jsc(ctx, _rval_);
  $-(/if)$
 $-(elif)$
        JSValueRef r__ = ::jsc::wrap_object(_rval_.get(), ifc->_context);
 $-(/if)$

 $-[args outarg?]$
  $-(if iref.false?)$
        static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
        jsc::set_property(ctx, r__, "$name$", read_to_jsc(ctx, $name$));
  $-(elif)$
        jsc::set_property(ctx, r__, "$name$", ::jsc::wrap_object($name$.get(), ifc->_context));
  $-(/if)$
 $[/args]-$
$-(elif noutargs?="1")$
 $-[args outarg?]$
  $-(if iref.false?)$
        static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
        JSValueRef r__ = read_to_jsc(ctx, $name$);
  $-(elif)$
        JSValueRef r__ = ::jsc::wrap_object(_rval_.get(), ifc->_context);
  $-(/if)$
 $[/args]-$
$-(elif noutargs?)$
        JSValueRef r__ = JSObjectMake(ctx, nullptr, nullptr);
 $-[args outarg?]$
  $-(if iref.false?)$
        static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
        set_proprety(ctx, r__, "$name$", read_to_jsc(ctx, $name$));
  $-(elif)$
        set_proprety(ctx, r__, "$name$", ::jsc::wrap_object($name$.get(), ifc->_context));
  $-(/if)$
 $[/args]-$
$-(elif)$
        JSValueRef r__ = JSValueMakeUndefined(ctx);
$(/if)-$

        return r__;
    } catch(const coid::exception& e) {
        *exception = jsc::throw_js(ctx, e.text());
        return JSValueMakeUndefined(ctx);
    }
}

$-[/method]$
$-[event]$

////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_js_dispatcher::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$) $-(if const?)$ const$(/if)$
{
$-(if internal?)$
    throw coid::exception("method not marked for scripting");
$-(elif)$
    bind_events(_context, false, JSValueMakeUndefined(_context));
    auto ev__ = _events[$@index$];

    if (!ev__ || JSValueIsUndefined(_context, ev__))
  $-(if default_event_body?)$ {
        $default_event_body$; $-(if return.type?="void")$
        return;
        $-(/if)$
    }
  $-(elif !mandatory?)$
        return;
  $-(elif)$
        throw coid::exception("handler not implemented");
  $-(/if)$

// prepare in arguments
$-[args inarg? iref.false?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
$-[/args]$

$-(if ninargs?)$
    JSValueRef __inargs[] = {
$-[args inarg? rest=","]$
        to_jsc$(if volatile ? )$_volatile$(/ if)$<$basetype$>::read(_context, $name$)
$-[/args]$
    };
$-(/if)$

//  event call
    JSValueRef exc = nullptr;
    JSValueRef r__ = JSObjectCallAsFunction(_context, _events[$@index$], _object, $(if ninargs?)$$ninargs$, __inargs$(elif)$0, 0$(/if)$, &exc);

$-[args inarg?]$$(if volatile?)$
    to_jsc$(if volatile?)$_volatile$(/if)$<$basetype$>::cleanup(_context, __inargs[$@order$]);$(/if)$
$-[/args]$

    if(exc) {
        jsc::script_handle::throw_js_error(_context, exc, "$..ns rest="::" after="::"$js::$..name$.$name$(): ");
    }

// gather results
$-(if !noutargs?)$

 $-(if return.type!="void")$
  $-(if return.iref.true?)$
    $return.type$ _rval_;
  $-(elif)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
    threadcached<$return.type$> _rval_;
  $-(/if)$
    write_from_jsc(_context, r__, _rval_);
 $-(/if)$
$-(elif)$
 $-(if return.type?="void" noutargs?="1")$

  $-[args outarg?]$
   $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
   $-(/if)$
   $-(if ptr?)$
    if ($name$)
        write_from_jsc(_context, r__, *$name$);
   $-(elif)$
    write_from_jsc(_context, r__, $name$);
   $-(/if)$
  $-[/args]$
 $-(elif)$

    if (!r__->IsObject()) throw coid::exception("invalid params");
    JSObjectRef obj__ = JSValueToObject(_context, r__, nullptr);
  $-(if return.type!="void")$

    //return value
   $-(if return.iref.true?)$
    $return.type$ _rval_;
    write_from_jsc(_context, r__, _rval_);
   $-(elif)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'" );
    threadcached<$return.type$> _rval_;
    write_from_jsc(_context, jsc::get_property(_context, obj__, "$$ret"), _rval_);
   $-(/if)$
  $-(/if)$
  $-[args outarg?]$

   $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
   $-(/if)$
   $-(if ptr?)$
    if ($name$)
        write_from_jsc(_context, jsc::get_property(_context, obj__, "$name$"), *$name$);
   $-(elif)$
    write_from_jsc(_context, jsc::get_property(_context, obj__, "$name$"), $name$);
   $-(/if)$
  $-[/args]$
 $-(/if)$
$(/if)-$

$-(if return.type!="void")$
    return _rval_;
$-(/if)$
$-(/if)$
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef $..name$_js_dispatcher::jsc_evback_$name$$@index$(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $..ns rest="::" after="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns rest="::" after="::"$js::$..name$_js_dispatcher*>(ptr->that);
    ifc->bind_events(ctx, false, JSValueMakeUndefined(ctx));
    auto ev__ = ifc->_events[$@index$];
    if (!ev__ || JSValueIsUndefined(ctx, ev__)) {
        const char* tmp = "Event not available: $name$";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

$-(if ninargs.nonzero?)$
    JSValueRef largs[$ninargs$];
    int nargs = (int)argumentCount;
    if (nargs > $ninargs$)
        nargs = $ninargs$;
    for (int i=0; i<nargs; ++i)
        largs[i] = arguments[i];
$-(/if)$

    JSValueRef r__ = JSObjectCallAsFunction(ctx, ev__, ifc->_object, $(if ninargs?)$nargs, largs$(elif)$0, 0$(/if)$, nullptr);
    return r__;
}

$-[/event]$
$-(if hasprops?)$
////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::_getter(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
{
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(object));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in []";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    charstr buf = jsc::to_charstr(propertyName);

$-(if getter.token?)$
    coid::token tok(buf);
    $getter.basetype$ value = (*R_)(tok);
$-(elif)$
    $getter.basetype$ value = (*R_)(buf);
$-(/if)$

$-(if getter.iref.false?)$
    static_assert( CHECK::meta_operator_exists<$getter.basetype$>::value, "missing metastream operator for '$getter.basetype$'" );
    JSValueRef r__ = read_to_jsc(ctx, value);
$-(elif)$
    JSValurRef r__ = ::jsc::wrap_object(value.get(), ifc->context(iso));
$-(/if)$

    return r__;
}

////////////////////////////////////////////////////////////////////////////////
bool $name$_js_dispatcher::_setter(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef* exception)
{
    if (!thisObject)
        return JSValueMakeUndefined(ctx);

    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(object));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);
    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        const char* tmp = "Null interface object in $..name$[] = ...";
        *exception = jsc::throw_js(ctx, tmp);
        return false;
    }

    static_assert( CHECK::meta_operator_exists<$setter.basetype$>::value, "missing metastream operator for '$setter.basetype$'" );
    threadcached<$setter.basetype$> val;
    write_from_jsc(ctx, value, val);

    charstr buf = jsc::to_charstr(propertyName);

    try {
$-(if setter.token?)$
        (*R_)(coid::token(buf), val);
$-(elif)$
        (*R_)(buf, val);
$-(/if)$
    }
    catch ( std::exception& e )
    {
        *exception = jsc::throw_js(ctx, e.what());
    }
    return true;
}
$-(/if)$


////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::jsc_log(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount == 0)
        return JSValueMakeUndefined(ctx);

    const void* inst = 0;

    if (thisObject) {
        jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
        if (ptr) {
            $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);
            inst = ifc;
            if (!ifc) {
                *exception = jsc::throw_js(ctx, "Null interface object in $$log");
                return JSValueMakeUndefined(ctx);
            }
        }
    }

    JSStringRef s = JSValueToStringCopy(ctx, arguments[0], 0);
    charstr buf = jsc::to_charstr(s);
    JSStringRelease(s);

    coid::token tokey(buf);

    intergen_interface::ifclog_ext(coid::log::none, coid::tokenhash("$ns rest="::" after="::"$$name$"),
        inst, tokey);

    return JSValueMakeUndefined(ctx);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::jsc_query_interface(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1) {
        *exception = jsc::throw_js(ctx, "Interface creator name missing");
        return JSValueMakeUndefined(ctx);
    }

    JSStringRef s = JSValueToStringCopy(ctx, arguments[0], exception);
    if (*exception) return JSValueMakeUndefined(ctx);
    charstr key = jsc::to_charstr(s);
    JSStringRelease(s);

    typedef JSValueRef (*fn_get)(JSContextRef, JSObjectRef, size_t, const JSValueRef[], interface_context*, JSValueRef*);
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(key));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << key << " not found";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);

    if (!ifc) {
        *exception = jsc::throw_js(ctx, "Null interface object in $$query_interface");
        return JSValueMakeUndefined(ctx);
    }

    return get(ctx, thisObject, argumentCount, arguments, ifc, exception);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::jsc_query_interface_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (argumentCount < 1) {
        *exception = jsc::throw_js(ctx, "Interface creator name missing");
        return JSValueMakeUndefined(ctx);
    }

    typedef JSValueRef (*fn_get)(JSContextRef, JSObjectRef, size_t, const JSValueRef[], interface_context*, JSValueRef*);

    JSStringRef s = JSValueToStringCopy(ctx, arguments[0], nullptr);
    charstr buf = jsc::to_charstr(s);
    JSStringRelease(s);
    fn_get get = reinterpret_cast<fn_get>(coid::interface_register::get_interface_creator(buf));

    if (!get) {
        coid::charstr tmp = "interface creator ";
        tmp << buf << " not found";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    return get(ctx, thisObject, argumentCount, arguments, 0, exception);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::jsc_rebind_events(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
$-(if event?)$
    if (!thisObject)
        return JSValueMakeUndefined(ctx);

    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);

    if (ifc) {
        JSValueRef val = nullptr;
        if (argumentCount > 0)
            val = arguments[0];
        ifc->bind_events(ctx, true, val);
    }

$-(/if)$
    return JSValueMakeUndefined(ctx);
}

////////////////////////////////////////////////////////////////////////////////
JSValueRef $name$_js_dispatcher::jsc_current_global(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
{
    if (!thisObject)
        return JSValueMakeUndefined(ctx);
    jsc::ifc_private_data* ptr = static_cast<jsc::ifc_private_data*>(JSObjectGetPrivate(thisObject));
    if (!ptr)
        return JSValueMakeUndefined(ctx);

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>(ptr->that);
    JSObjectRef g = JSContextGetGlobalObject(ctx);
    JSValueRef prototype = JSObjectGetPrototype(ctx, g);
    return prototype;
}


////////////////////////////////////////////////////////////////////////////////
JSObjectRef $name$_js_dispatcher::create_interface_object( JSContextRef context, bool make_weak )
{
    _is_weak = make_weak;

    static JSClassRef cls = nullptr;
    if (!cls) {
        JSClassDefinition def = kJSClassDefinitionEmpty;
        const JSStaticFunction funcs[] = {
            { "$$query_interface", &jsc_query_interface, 0 },
            { "$$rebind_events", &jsc_rebind_events, 0 },
            { "$$log", &jsc_log, 0 },
            { "$$ctx", &jsc_current_global, 0 },
$-[method !static? !destroy? !internal? !operator?]$
            { "$name$", &jsc_$name$$@index$, 0 },
$-[/method]$
$-(if event.nonzero?)$
        //event wrappers for event invocation from outside js
$-[event]$
            { "$name$", &jsc_evback_$name$$@index$, 0 },
$-[/event]$
$-(/if)$
            { nullptr, nullptr, 0 },
        };
        def.staticFunctions = funcs;
$-(if hasprops?)$
        def.getProperty = _getter;
        def.setProperty = _setter;
$-(/if)$
        def.finalize = _finalizer;
        cls = JSClassCreate(&def);
    }

    jsc::ifc_private_data* p = new jsc::ifc_private_data;
    p->that = this;
    p->hash = $hash$;
    JSObjectRef obj = JSObjectMake(context, cls, p);

    if (make_weak) {
        add_refcount();
    }
    else {
        JSValueProtect(context, obj);
    }

    return obj;
}

$-(if event.empty!)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::bind_events( JSContextRef context, bool force, JSValueRef ref ) const
{
    if (!force && _bound_events)
        return;

    static const char* names[] = {
$-[event]$
        "$name$",
$-[/event]$
    };

    JSObjectRef global = nullptr;

    bool clear = false;
    if (!ref || JSValueIsUndefined(context, ref))
        global = JSContextGetGlobalObject(context);
    else if (JSValueIsNull(context, ref))
        clear = true;
    else
        global = JSValueToObject(context, ref, nullptr);

    for (int i=0; i<$event.@size$; ++i)
    {
        if (_events[i])
            JSValueUnprotect(context, _events[i]);
        _events[i] = nullptr;
        if (clear)
            continue;

        JSValueRef var = jsc::get_property(context, global, names[i]);

        if (!var || JSValueIsUndefined(context, var))
            continue;

        if (JSValueIsObject(context, var)) {
            JSObjectRef obj = JSValueToObject(context, var, nullptr);
            if (JSObjectIsFunction(context, obj))
                _events[i] = obj;
        }
    }

    _bound_events = true;
}
$-(/if)$
// --- creators ---

$-[method static? !ifccr?]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_js_dispatcher> $..name$_js_dispatcher::$name$( const jsc::script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, JSContextRef* ctx )
{
    JSContextRef context = nullptr;

    // create interface object
    iref<$..name$_js_dispatcher> ifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $name$$[/args]$);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef JSContextRef (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (!context)
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = context;

    ifc->_own_context = false;
    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = JSGlobalContextCreateInGroup(jsc::jsc_get_current_group(), 0);
            ifc->_own_context = true;
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = context;

    ifc->_context = context;

    JSObjectRef global = JSContextGetGlobalObject(context);
    if (!extctx && !script.is_context())
    {
        if (!script.has_context()) {
            jsc::set_property(context, global, "$$include", &jsc::script_handle::js_include);
            jsc::set_property(context, global, "$$query_interface", &$..name$_js_dispatcher::jsc_query_interface_global);
            jsc::set_property(context, global, "$$log", &$..name$_js_dispatcher::jsc_log);
        }

        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object = ifc->create_interface_object(context, false);

        if (bindname) {
            zstring buf = bindname;
            jsc::set_property(context, global, buf.c_str(), ifc->_object);
        }

        zstring src = script_tok;
        JSStringRef js_src = JSStringCreateWithUTF8CString(src.c_str());
        JSValueRef exc = nullptr;
        JSEvaluateScript(context, js_src, 0, 0, 0, &exc);
        if (exc)
            jsc::script_handle::throw_js_error(context, exc);

        JSStringRelease(js_src);
    }
    else {
        ifc->_object = ifc->create_interface_object(context, false);

        if (bindname) {
            zstring buf = bindname;
            jsc::set_property(context, global, buf.c_str(), ifc->_object);
        }
    }

    return ifc;
}

$-(if !internal?)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
JSValueRef $..name$_js_dispatcher::jsc_creator_$name$$@order$(JSContextRef ctx, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], interface_context* ifc, JSValueRef* exception)
{
    if (argumentCount < 1+$ninargs_nondef$ || argumentCount > 1+$ninargs$) { //fnc name + in/inout arguments
        const char* tmp = "Wrong number of arguments in $name$";
        *exception = jsc::throw_js(ctx, tmp);
        return JSValueMakeUndefined(ctx);
    }

    //stream the arguments in
$-[args inarg? !nojs?]$
 $-(if iref.false?)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
 $-(/if)$
$-[/args]$
$-[args inarg? !nojs?]$
 $-(if ptr? !defval.empty?)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if (1 + $@order$ < argumentCount)
        write_from_jsc(ctx, arguments[1+$@order$], $name$__tmp);
    else
        $name$ = $defval$;
 $-(elif !defval.empty?)$
    threadcached<$basetype$> $name$;
    if (1 + $@order$ < argumentCount)
        write_from_jsc(ctx, arguments[1+$@order$], $name$);
    else
        $name$ = $defval$;
 $-(elif)$
    threadcached<$basetype$> $name$;
    write_from_jsc(ctx, arguments[1+$@order$], $name$);
 $-(/if)$
$[/args]-$

    //invoke
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    iref<$..name$_js_dispatcher> nifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $(if ptr? outarg?)$&$(elif ptr? defval.empty? !specptr?)$&$(/if)$$name$$[/args]$);

    //stream out
$-(if noutargs?)$
    JSObjectRef r__ = JSObjectMake(ctx, nullptr, nullptr);
    jsc::set_property(ctx, r__, "$$ret", nifc
        ? nifc->create_interface_object(ctx, true)
        : JSValueMakeNull(ctx));
$-(elif)$
    JSValueRef r__ = nifc
        ? nifc->create_interface_object(ctx, true)
        : JSValueMakeNull(ctx);
$-(/if)$

$-[args outarg?]$
    $-(if iref.false?)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
    $-(/if)$
    jsc::set_property(ctx, r__, "$name$", read_to_jsc(ctx, $name$));
$[/args]-$

    return r__;
}

$-(/if)$
$-[/method]$
$-(if virtual!)$
////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
JSValueRef create_wrapper_$name$( ::$ns rest="::" after="::"$$name$* orig, JSContextRef context )
{
    // check that the orig points to an object
    if (!orig) return JSValueMakeNull(context);

    iref<$ns rest="::" after="::"$js::$name$_js_dispatcher> ifc;
    JSObjectRef obj = nullptr;

    if (orig->intergen_backend() == intergen_interface::backend::js) {
        auto jsd = static_cast<$name$_js_dispatcher*>(orig);
        if(jsd->is_weak()) {
            obj = jsd->_object;
        }
    }

    if (!obj) {
        // create interface object
        ifc.create(new $ns rest="::" after="::"$js::$name$_js_dispatcher(static_cast<::$ns rest="::" after="::"$$name$*>(orig)));

        obj = ifc->create_interface_object(context, true);
    }

    return obj;
}


////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<$ns rest="::" after="::"$js::$name$_js_dispatcher> create_maker_$name$( policy_intrusive_base* host, JSContextRef context )
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    iref<$ns rest="::" after="::"$js::$name$_js_dispatcher> ifc;

    ifc.create(new $ns rest="::" after="::"$js::$name$_js_dispatcher);
    ifc->set_host(host);

    ifc->create_interface_object(context, false);

    return ifc;
}
$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$( bool on )
{
$-[method static? !ifccr?]$
    //c++ creator of JS interface object
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$$..name$.$name$@creator.js",
        on ? (void*)&$..name$_js_dispatcher::$name$ : nullptr);
$-(if !internal?)$

    //creator from script
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$js::$..name$.$name$",
        on ? (void*)&$..name$_js_dispatcher::jsc_creator_$name$$@order$ : nullptr);
$-(/if)$
$-[/method]$
$-(if virtual!)$

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "$ns rest="::" after="::"$$name$@wrapper.js",
        on ? (void*)&create_wrapper_$name$ : nullptr);

    //js interface creator from host
    interface_register::register_interface_creator(
        "$ns rest="::" after="::"$$name$@maker.js",
        on ? (void*)&create_maker_$name$ : nullptr);
$-(/if)$
}


//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);


void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace js
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface]$$[/class]$
