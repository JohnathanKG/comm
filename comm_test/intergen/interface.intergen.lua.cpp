
//@file  lua interface dispatcher generated by intergen v9
//See LICENSE file for copyright and license information

#include "ifc/lua/client.h"
#include "ifc/lua/client2.h"
#include "interface.hpp"

#include <comm/intergen/ifc.lua.h>
#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_lua_capi.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface client of class host
//
////////////////////////////////////////////////////////////////////////////////
namespace lua {

////////////////////////////////////////////////////////////////////////////////
class client_lua_dispatcher
    : public ::lua::interface_wrapper_base<::client>
{
    mutable iref<::lua::weak_registry_handle> _events[3];
    mutable bool _bound_events;

    void init_event_registry() {
        for (int i = 0; i < 3; i++) {
            _events[i] = nullptr;
        }
    }

protected:

    backend intergen_backend() const override { return backend::lua; }
    //static constexpr coid::token lua_interface_class_name() {  return "client"_T; };

    // Tests if table on the top of the stack contains field with this iterface calss
    //@param push_on_top - if the call table is found, it is pushed on the top of the stack
    //@return - true if this class table including namespace tables are contained in the table on the top of the stack
    static bool contains_interface_class_table_internal(lua_State* L, bool push_on_top);
    // Gets this class interface table from the table on the top of the stack and pushes it on the top
    //@note - you must be 100% sure the class interface table is contained by the table on the top of the stack!!!
    static void get_interface_class_table_internal(lua_State* L);
public:

    /// Creates script iterface object in the context of this dispatcher
    /// @param make_weak - created interface object will be weak
    /// @param script_class_or_bind_var - script class name or binding variable name (see note)
    /// @param is_bind_var - specifies if script_class_or_bind_var argument should be interpreted as bind variable name or script class name
    /// @note is_bind_var is false, created interface objects will inherited from the table with name "script_class"
    /// @note is_bind_var is true, created interface objects will use existing table variable with "bind_var" name
    /// @note if script_class_or_bind_var is empty and is_bind_var is false created interface object is creted from empty table
    iref<::lua::registry_handle> create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var);
    void bind_events_internal(lua_State * L, bool clear) const;
    void bind_events(bool force, const coid::token& script_class_name) const;

    COIDNEWDELETE(client_lua_dispatcher);

    client_lua_dispatcher() : _bound_events(false)
    {
        init_event_registry();
    }

    explicit client_lua_dispatcher(iref<::lua::registry_handle> context, client* orig) : _bound_events(false) {
        _base.create(orig);
        _vtable = _base->vtable();

        set_context(context);

        _host = _base->host<policy_intrusive_base>();

        init_event_registry();
    }


    explicit client_lua_dispatcher(policy_intrusive_base* host) : _bound_events(false)
    {
        set_host(host, this, 0);
    }

    ~client_lua_dispatcher() {

    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    static int register_interface_client(lua_State * L, bool push);
    static int register_implementation_client(lua_State * L, const coid::token& implementation_script_class_name);

    // --- creators ---

    /// @brief interface creator
    /// @return host class instance
    static iref<client_lua_dispatcher> creator(lua_State * L, const ::lua::script_handle& scriptpath, const coid::token& bind_variable_name, const coid::token& script_class_name, iref<::lua::registry_handle>*);

    static int luacreator_creator0(lua_State * L, ::lua::interface_context* ifc);

    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

    static int lua_set_def0_exc(lua_State * L);
    static int lua_set_def0(lua_State * L);
    static bool can_use_ffi_set_def0();
    static void get_ffi_inject_set_def0(coid::token& header, coid::token& body);
    static void lua_set_def0_ffi(void * ifc_this, const flags& flg);
    static int lua_set1_exc(lua_State * L);
    static int lua_set1(lua_State * L);
    static bool can_use_ffi_set1();
    static void get_ffi_inject_set1(coid::token& header, coid::token& body);
    static void lua_set1_ffi(void * ifc_this, const coid::token& par);
    static int lua_get2_exc(lua_State * L);
    static int lua_get2(lua_State * L);
    static bool can_use_ffi_get2();
    static void get_ffi_inject_get2(coid::token& header, coid::token& body);
    static int lua_get2_ffi(void * ifc_this, coid::charstr& par);
    static int lua_custom3_exc(lua_State * L);
    static int lua_custom3(lua_State * L);
    static bool can_use_ffi_custom3();
    static void get_ffi_inject_custom3(coid::token& header, coid::token& body);
    static sometype lua_custom3_ffi(void * ifc_this);
    static int lua_overridable4_exc(lua_State * L);
    static int lua_overridable4(lua_State * L);
    static bool can_use_ffi_overridable4();
    static void get_ffi_inject_overridable4(coid::token& header, coid::token& body);
    static bool lua_overridable4_ffi(void * ifc_this);

    // --- interface events ---

    virtual void echo( int k ) override;
    virtual void callforth( void cbk ) override;
    virtual int required( int x ) override;

    virtual bool is_bound(event m) override {
        //if (!_bound_events) {
        //    static ::lua::registry_handle empty_registry_handle;
        //    bind_events(false, iref<::lua::registry_handle>(&empty_registry_handle));
        //}

        //return !_events[int(m)];
        return true;
    }

virtual void force_bind_script_events() {
    //static ::lua::registry_handle empty_registry_handle;
    DASSERT(0);
    //bind_events(true, iref<::lua::registry_handle>(&empty_registry_handle));
    //bind_events(true, iref<::lua::registry_handle>(&empty_registry_handle));
}

private:
    bool is_event_bound(int id)
    {
        /*if (!_bound_events) {
            static ::lua::registry_handle empty_registry_handle;
            bind_events(false, iref<::lua::registry_handle>(&empty_registry_handle));
        }*/

        return  true;//_bound_events && _events[id];
    }

    //event wrappers for event invocation from lua
    static int lua_evback_echo0(lua_State * L);
    static int lua_evback_callforth1(lua_State * L);
    static int lua_evback_required2(lua_State * L);
};

////////////////////////////////////////////////////////////////////////////////
//
//  void client::set_def( const flags& flg)
//
__declspec(noinline) int client_lua_dispatcher::lua_set_def0_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 1) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client.set_def";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client.set_def";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<::client>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::client>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client.set_def";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in
        static_assert(coid::has_metastream_operator<flags>::value, "missing metastream operator for 'flags'");

        lua_pushvalue(L, 0 + 2);

        threadcached<flags> flg;
        if (0 < args_count)
            from_lua(flg);
        else
            flg = {.a = 1, .b = 2};

        lua_pop(L, 1); // who pushes, must pop!

        //out params

        // invoke
        R_->set_def(flg);

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);
        return 0;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client_lua_dispatcher::lua_set_def0(lua_State * L){
    int res = lua_set_def0_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client_lua_dispatcher::can_use_ffi_set_def0(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client_lua_dispatcher::get_ffi_inject_set_def0(coid::token& header, coid::token& body){
    static const coid::token h = "typedef void (*client_set_def0_fun)(void * ifc_this, const flags& flg)\n";
    header = h;
    static const coid::token b =
"client.set_def_ffi = ffi.cast(\"client_set_def0_fun\",client.set_def);\n"\
"function client:set_def(flg,)\n"\
"   return client.set_def_ffi(self.__cthis, flg)\n"\
"end;\n";
    body = b;
}
/*
void client_lua_dispatcher::lua_set_def0_ffi(void * ifc_this, const flags& flg){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  void client::set( const coid::token& par)
//
__declspec(noinline) int client_lua_dispatcher::lua_set1_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 1 || args_count > 1) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client.set";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client.set";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<::client>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::client>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client.set";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in
        static_assert(coid::has_metastream_operator<coid::token>::value, "missing metastream operator for 'coid::token'");

        lua_pushvalue(L, 0 + 2);

        threadcached<coid::token> par;
        from_lua(par);

        lua_pop(L, 1); // who pushes, must pop!

        //out params

        // invoke
        R_->set(par);

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);
        return 0;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client_lua_dispatcher::lua_set1(lua_State * L){
    int res = lua_set1_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client_lua_dispatcher::can_use_ffi_set1(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client_lua_dispatcher::get_ffi_inject_set1(coid::token& header, coid::token& body){
    static const coid::token h = "typedef void (*client_set1_fun)(void * ifc_this, const coid::token& par)\n";
    header = h;
    static const coid::token b =
"client.set_ffi = ffi.cast(\"client_set1_fun\",client.set);\n"\
"function client:set(par,)\n"\
"   return client.set_ffi(self.__cthis, par)\n"\
"end;\n";
    body = b;
}
/*
void client_lua_dispatcher::lua_set1_ffi(void * ifc_this, const coid::token& par){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  int client::get( coid::charstr& par)
//
__declspec(noinline) int client_lua_dispatcher::lua_get2_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client.get";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client.get";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<::client>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::client>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client.get";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in


        //out params
        coid::charstr par;

        // invoke
        int rval__ = R_->get(par);

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream out
        lua_createtable(L, 0, 2);
        to_lua(rval__); lua_setfield(L, -2, "_ret");
        to_lua(par);

        return 2;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client_lua_dispatcher::lua_get2(lua_State * L){
    int res = lua_get2_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client_lua_dispatcher::can_use_ffi_get2(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client_lua_dispatcher::get_ffi_inject_get2(coid::token& header, coid::token& body){
    static const coid::token h = "typedef int (*client_get2_fun)(void * ifc_this, coid::charstr& par)\n";
    header = h;
    static const coid::token b =
"client.get_ffi = ffi.cast(\"client_get2_fun\",client.get);\n"\
"function client:get(par,)\n"\
"   return client.get_ffi(self.__cthis, par)\n"\
"end;\n";
    body = b;
}
/*
int client_lua_dispatcher::lua_get2_ffi(void * ifc_this, coid::charstr& par){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  sometype client::custom()
//
__declspec(noinline) int client_lua_dispatcher::lua_custom3_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client.custom";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client.custom";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<::client>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::client>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client.custom";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in


        //out params

        // invoke
        sometype rval__ = R_->custom();

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream out
        to_lua(rval__);

        return 1;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client_lua_dispatcher::lua_custom3(lua_State * L){
    int res = lua_custom3_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client_lua_dispatcher::can_use_ffi_custom3(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client_lua_dispatcher::get_ffi_inject_custom3(coid::token& header, coid::token& body){
    static const coid::token h = "typedef sometype (*client_custom3_fun)(void * ifc_this)\n";
    header = h;
    static const coid::token b =
"client.custom_ffi = ffi.cast(\"client_custom3_fun\",client.custom);\n"\
"function client:custom()\n"\
"   return client.custom_ffi(self.__cthis)\n"\
"end;\n";
    body = b;
}
/*
sometype client_lua_dispatcher::lua_custom3_ffi(void * ifc_this){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  bool client::overridable()
//
__declspec(noinline) int client_lua_dispatcher::lua_overridable4_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client.overridable";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client.overridable";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<::client>* ifc = reinterpret_cast<::lua::interface_wrapper_base<::client>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client.overridable";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in


        //out params

        // invoke
        bool rval__ = R_->overridable();

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream out
        to_lua(rval__);

        return 1;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client_lua_dispatcher::lua_overridable4(lua_State * L){
    int res = lua_overridable4_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client_lua_dispatcher::can_use_ffi_overridable4(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client_lua_dispatcher::get_ffi_inject_overridable4(coid::token& header, coid::token& body){
    static const coid::token h = "typedef bool (*client_overridable4_fun)(void * ifc_this)\n";
    header = h;
    static const coid::token b =
"client.overridable_ffi = ffi.cast(\"client_overridable4_fun\",client.overridable);\n"\
"function client:overridable()\n"\
"   return client.overridable_ffi(self.__cthis)\n"\
"end;\n";
    body = b;
}
/*
bool client_lua_dispatcher::lua_overridable4_ffi(void * ifc_this){

}
*/
////////////////////////////////////////////////////////////////////////////////
void client_lua_dispatcher::echo( int k )
{
    DASSERT(_bound_events);
    //bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[0];

    if (ev__->is_empty())
        return;

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert(coid::has_metastream_operator<int>::value, "missing metastream operator for 'int'");

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushcfunction(L, &::lua::catch_lua_error); // push pcall error handler
// stream in args and lua function for event call
    ev__->push_ref();
    _object->push_ref();

    DASSERT(lua_isfunction(L, -2)); // check if event is valid
    DASSERT(lua_istable(L, -1)); // check if self param

    lua_streamer<int>::to_lua(k); // TODO: volatile streamers

    constexpr uint nres = 0;
// call event
    int res = lua_pcall(L,1 + 1,nres,-3-1);

    if (res != 0) {
        if (0)
        {
            ::lua::debug_print_stack(L);
        }

        lua_remove(L, -2); // pop pcall error handler
#ifdef _DEBUG
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == stack_top + 1); // +1 because error message is on the stack
#endif

        ::lua::throw_lua_error(L, "");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);


    lua_pop(L, 1); // pop pcall error handler
#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif

}

////////////////////////////////////////////////////////////////////////////////
void client_lua_dispatcher::callforth( void cbk )
{
    throw coid::exception("method not marked for scripting");
}

////////////////////////////////////////////////////////////////////////////////
int client_lua_dispatcher::required( int x )
{
    DASSERT(_bound_events);
    //bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[2];

    if (ev__->is_empty())
        throw coid::exception("required handler not implemented");

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
    static_assert(coid::has_metastream_operator<int>::value, "missing metastream operator for 'int'");

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushcfunction(L, &::lua::catch_lua_error); // push pcall error handler
// stream in args and lua function for event call
    ev__->push_ref();
    _object->push_ref();

    DASSERT(lua_isfunction(L, -2)); // check if event is valid
    DASSERT(lua_istable(L, -1)); // check if self param

    lua_streamer<int>::to_lua(x); // TODO: volatile streamers

    constexpr uint nres = 1;

// call event
    int res = lua_pcall(L,1 + 1,nres,-3-1);

    if (res != 0) {
        if (0)
        {
            ::lua::debug_print_stack(L);
        }

        lua_remove(L, -2); // pop pcall error handler
#ifdef _DEBUG
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == stack_top + 1); // +1 because error message is on the stack
#endif

        ::lua::throw_lua_error(L, "");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

    static_assert(coid::has_metastream_operator<int>::value, "missing metastream operator for 'int'");
    threadcached<int> _rval_;
    try{
        from_lua(_rval_);
        lua_pop(L, 1); // pop return value
    }
    catch (const coid::exception& e)
    {
        lua_pop(L, 2); // pop return value and pcall error handler;
        throw e;
    }

    lua_pop(L, 1); // pop pcall error handler
#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif

    return _rval_;
}



////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int client_lua_dispatcher::luarebind_events_exc(lua_State * L)
{
    try {
        if (!lua_istable(L,-2) || !lua_hasfield(L, -2, ::lua::_lua_dispatcher_cptr_key))
            return 0;

        lua_getfield(L, -2, ::lua::_lua_dispatcher_cptr_key);
        if (!lua_isuserdata(L,-1))
            return 0;

        lua::client_lua_dispatcher* ifc = reinterpret_cast<lua::client_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        lua_pop(L, 1); // pop user data

        // now only script object with events is on the top of the stack

        if (ifc) {
            if (ifc->intergen_real_interface() != ifc)
            {
                ifc->assign_safe(nullptr, nullptr);
                ifc->assign_safe(ifc, nullptr);
            }

            ifc->bind_events_internal(L, false);
         }
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return 0;
}

int client_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////

bool client_lua_dispatcher::contains_interface_class_table_internal(lua_State * L, bool push_on_top)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    int num_pops = 0;
    constexpr int num_namespaces = 0;

    bool result = (num_pops == num_namespaces) && lua_hasfield(L, -1, "client");

    if (push_on_top && result)
    {
        lua_getfield(L, -1, "client");
        lua_insert(L, -1 - num_namespaces);
    }

    lua_pop(L, num_pops);

    DASSERT((result&& push_on_top) ? (stack_top + 1 == lua_gettop(L)) : (stack_top == lua_gettop(L)));

    return result;
}

////////////////////////////////////////////////////////////////////////////////

void client_lua_dispatcher::get_interface_class_table_internal(lua_State* L)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    DASSERT(contains_interface_class_table_internal(L, false));

    constexpr int num_namespaces = 0;

    lua_getfield(L, -1, "client");
    lua_insert(L, -1 - num_namespaces);
    lua_pop(L, num_namespaces);

    DASSERT(stack_top + 1 == lua_gettop(L));
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> client_lua_dispatcher::create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var)
{
    lua_State * L = context->get_state();

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    context->push_ref();

    if(!is_bind_var)
    {
        // get object table
        lua_createtable(L, 0, 3);
    }
    else
    {
        if (!lua_hasfield(L, -1, script_class_or_bind_var))
        {
            lua_pop(L, 1); // pop context table
            coid::exception e("");
            e << "Given contex doesn't contain object binding variable with name " << script_class_or_bind_var << "!";
            throw e;
        }

        // get object table
        lua_getfield(L, -1, script_class_or_bind_var);
    }

    // get metatable
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_dispatcher_cptr_key);

    cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this->intergen_real_interface());
    lua_setfield(L, -2, ::lua::_lua_interface_cptr_key);

    lua_pushnumber(L, ints(1781368982));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);


    if (0)
    {
        ::lua::debug_print_stack(L);
    }

    // set index table
    if (!is_bind_var && !script_class_or_bind_var.is_empty())
    {
        if (!lua_hasfield(L, -2, script_class_or_bind_var))
        {
            lua_pop(L, 2); // pop context and object table
            coid::exception e("");
            e << "Given contex doesn't contain script class with name " << script_class_or_bind_var << "!";
            throw e;
        }

        lua_getfield(L, -2, script_class_or_bind_var);
    }
    else
    {
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
        if (!contains_interface_class_table_internal(L, true))
        {
            register_interface_client(L, true);
        }

        lua_remove(L, -2); // remove interface metatable register table
    }
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_dispatcher_cptr_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_METATABLE_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();

    lua_pop(L, 1); // pop context table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(stack_top == current_stack_top);
    }
#endif

    _object = obj;
    set_context(context);
    return obj;
}



void client_lua_dispatcher::bind_events_internal(lua_State * L,  bool clear) const
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif
    static token names[] = {
        "echo",
        "callforth",
        "required",
    };

    for (int i = 0; i<3; ++i)
        {
            _events[i].create(new ::lua::weak_registry_handle(L));

            if (clear) {
                continue;
            }
            lua_getfield(L, -1, names[i]);
            if (!lua_isfunction(L, -1)) {
                lua_pop(L, 1);
                continue;
            }

            _events[i]->set_ref();
        }

        _bound_events = true;

#ifdef _DEBUG
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == stack_top);
#endif
}

////////////////////////////////////////////////////////////////////////////////
void client_lua_dispatcher::bind_events(bool force, const coid::token& script_class_name) const
{
    if (!force && _bound_events)
        return;

    lua_State * L = _context->get_state();
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif
    _object->push_ref();  // push interface object table
    _context->push_ref(); // push context table

    if (script_class_name.is_empty())
    {
        if (!contains_interface_class_table_internal(L, true))
        {
            lua_pop(L, 2); // pop interface object and context table
            coid::exception e("");
            e << "Script doesn't implements this class '" << "client" << "'!";
            throw e;

        }
    }
    else
    {
        if (!lua_hasfield(L, -1, script_class_name)) {
            lua_pop(L, 2); // pop interface object and context table
            coid::exception e("Script doesn't implements this class '");
            e << script_class_name << "'!";
            throw e;
        }

        lua_getfield(L, -1, script_class_name); // push script class table on the top of the stack
    }

    bind_events_internal(L, false);

    lua_pop(L, 3); // interface object, context and script class table

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif
}


// --- registrar ---
int client_lua_dispatcher::register_interface_client(lua_State * L, bool push) {
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table

    lua_createtable(L, 0, 0);

    lua_pushcfunction(L, &client_lua_dispatcher::lua_set_def0);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "set_def");

    lua_pushcfunction(L, &client_lua_dispatcher::lua_set1);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "set");

    lua_pushcfunction(L, &client_lua_dispatcher::lua_get2);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "get");

    lua_pushcfunction(L, &client_lua_dispatcher::lua_custom3);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "custom");

    lua_pushcfunction(L, &client_lua_dispatcher::lua_overridable4);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "overridable");

    lua_pushcfunction(L, &client_lua_dispatcher::luarebind_events);
    lua_setfield(L, -2, ::lua::_lua_rebind_events_key);

    if (push)
    {
        lua_pushvalue(L, -1);
        lua_insert(L, -3);
    }

    lua_setfield(L, -2, "client");
    lua_pop(L, 1); // pop namespace or interface metatable register table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == (push ? stack_top + 1 : stack_top)); // ensure we left the stack in the initial state
    }
#endif

    return 0;
}

int client_lua_dispatcher::register_implementation_client(lua_State * L, const coid::token& implementation_script_class_name)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context


    lua_createtable(L, 0, 0); // table for class
    lua_pushvalue(L, -1); // get metatable
    lua_setmetatable(L, -2); // it is its own metatable

    // new we set __index table to aquire methods for c interface
    lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    if (!contains_interface_class_table_internal(L, true))
    {
        register_interface_client(L, true);
    }

    lua_remove(L, -2); // remove interface metatable register table
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "echo");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "callforth");

    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "required");

    lua_setfield(L, -2, implementation_script_class_name.is_empty()? "client" : implementation_script_class_name);
    lua_pop(L, 1); // pop namespace or script context table

#ifdef _DEBUG
    DASSERT(lua_gettop(L) == stack_top); // ensure we left the stack in the initial state
#endif

    if (0)
    {
        lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context
        lua_hasfield(L, -1, "a.b.parent_class_ifc");
        ::lua::debug_print_stack(L);
    }

    return 0;
}


// --- creators ---

////////////////////////////////////////////////////////////////////////////////
iref<client_lua_dispatcher> client_lua_dispatcher::creator(lua_State * L, const ::lua::script_handle& script, const coid::token& bind_variable_name, const coid::token& script_class_name, iref<::lua::registry_handle>* ctx)
{

    // create interface object
    iref<client_lua_dispatcher> ifc = client::creator(new client_lua_dispatcher);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    try
    {
        iref<::lua::registry_handle> context = script.load_script(L);

        if (ctx)
            *ctx = context;

        ifc->set_context(context);

        const bool is_bind_var = !bind_variable_name.is_empty();
        ifc->_object = ifc->create_interface_object(context, false, is_bind_var ? bind_variable_name : script_class_name, is_bind_var);

        ifc->bind_events(false, script_class_name);
    }
    catch (coid::exception& e)
    {
        throw e;
    }

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif
    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<client> client::creator()
///

int client_lua_dispatcher::luacreator_creator0(lua_State * L, ::lua::interface_context* ifc)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    const int args_count = lua_gettop(L);

    if (args_count < 0 || args_count > 0) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "client.creator";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

//out params
    iref<client_lua_dispatcher> nifc = client::creator(new client_lua_dispatcher);

    //stream out
    if (nifc) {
        iref<::lua::registry_handle> context = nullptr;
        if (ifc) {
            context = ifc->_context;
        }
        else {
            context.create(new ::lua::weak_registry_handle(L));
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            context->set_ref();
        }

        nifc->create_interface_object(context, true, "", false)->push_ref();
    }
    else {
        lua_pushnil(L);
    }

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top + 1); // starting top + number of results
#endif

    return 1;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_client(::client* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<lua::client_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::backend::lua)
        obj = static_cast<client_lua_dispatcher*>(orig)->_object;

    if (obj.is_empty()) {
        // create interface object
        ifc.create(new lua::client_lua_dispatcher(context, static_cast<::client*>(orig)));

        obj = ifc->create_interface_object(context, true, "", false);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA interface from a host
static iref<lua::client_lua_dispatcher> create_maker_client(policy_intrusive_base* host, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    iref<lua::client_lua_dispatcher> ifc;

    ifc.create(new lua::client_lua_dispatcher(host));
    ifc->create_interface_object(context, false, "", false);
    ifc->bind_events(false, "");

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_client(bool on)
{
    // implement in context function
    interface_register::register_interface_creator("lua::implement_class.client", on ? (void*)&client_lua_dispatcher::register_implementation_client : nullptr, nullptr);

    //c++ creator of Lua interface object
    interface_register::register_interface_creator("client.creator@creator.lua", on ? (void*)&client_lua_dispatcher::creator : nullptr, nullptr);

    //creator from script
    interface_register::register_interface_creator("lua.client.creator", on ? (void*)&client_lua_dispatcher::luacreator_creator0 : nullptr, nullptr);

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator("client@wrapper.lua", on ? (void*)&create_wrapper_client : nullptr, nullptr);

    //js interface creator from host
    interface_register::register_interface_creator("client@maker.lua", on ? (void*)&create_maker_client : nullptr, nullptr);
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) client_autoregger = new ifc_autoregger(&register_binders_for_client);

void* force_register_client() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_client);
    return autoregger.get();
}

} //namespace lua




////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface client2 of class host
//
////////////////////////////////////////////////////////////////////////////////
namespace xt {
namespace lua {

////////////////////////////////////////////////////////////////////////////////
////
class client2_lua_dispatcher
    : public ::lua::interface_wrapper_base<xt::client2>
{
protected:

    backend intergen_backend() const override { return backend::lua; }
    //static constexpr coid::token lua_interface_class_name() {  return "client2"_T; };

    // Tests if table on the top of the stack contains field with this iterface calss
    //@param push_on_top - if the call table is found, it is pushed on the top of the stack
    //@return - true if this class table including namespace tables are contained in the table on the top of the stack
    static bool contains_interface_class_table_internal(lua_State* L, bool push_on_top);
    // Gets this class interface table from the table on the top of the stack and pushes it on the top
    //@note - you must be 100% sure the class interface table is contained by the table on the top of the stack!!!
    static void get_interface_class_table_internal(lua_State* L);
public:

    /// Creates script iterface object in the context of this dispatcher
    /// @param make_weak - created interface object will be weak
    /// @param script_class_or_bind_var - script class name or binding variable name (see note)
    /// @param is_bind_var - specifies if script_class_or_bind_var argument should be interpreted as bind variable name or script class name
    /// @note is_bind_var is false, created interface objects will inherited from the table with name "script_class"
    /// @note is_bind_var is true, created interface objects will use existing table variable with "bind_var" name
    /// @note if script_class_or_bind_var is empty and is_bind_var is false created interface object is creted from empty table
    iref<::lua::registry_handle> create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var);

    COIDNEWDELETE(client2_lua_dispatcher);

    client2_lua_dispatcher()
    {    }

    explicit client2_lua_dispatcher(iref<::lua::registry_handle> context, xt::client2* orig) {
        _base.create(orig);
        _vtable = _base->vtable();

        set_context(context);

        _host = _base->host<policy_intrusive_base>();
    }


    explicit client2_lua_dispatcher(policy_intrusive_base* host)
    {
        set_host(host, this, 0);
    }

    ~client2_lua_dispatcher() {

    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    static int register_interface_client2(lua_State * L, bool push);
    static int register_implementation_client2(lua_State * L, const coid::token& implementation_script_class_name);

    // --- creators ---


    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

    static int lua_test0_exc(lua_State * L);
    static int lua_test0(lua_State * L);
    static bool can_use_ffi_test0();
    static void get_ffi_inject_test0(coid::token& header, coid::token& body);
    static void lua_test0_ffi(void * ifc_this);
    static int lua_get1_exc(lua_State * L);
    static int lua_get1(lua_State * L);
    static bool can_use_ffi_get1();
    static void get_ffi_inject_get1(coid::token& header, coid::token& body);
    static coref<component_ifc> lua_get1_ffi(void * ifc_this);
};

////////////////////////////////////////////////////////////////////////////////
//
//  void xt::client2::test()
//
__declspec(noinline) int client2_lua_dispatcher::lua_test0_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client2.test";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client2.test";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<xt::client2>* ifc = reinterpret_cast<::lua::interface_wrapper_base<xt::client2>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client2.test";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in


        //out params

        // invoke
        R_->test();

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);
        return 0;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client2_lua_dispatcher::lua_test0(lua_State * L){
    int res = lua_test0_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client2_lua_dispatcher::can_use_ffi_test0(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client2_lua_dispatcher::get_ffi_inject_test0(coid::token& header, coid::token& body){
    static const coid::token h = "typedef void (*client2_test0_fun)(void * ifc_this)\n";
    header = h;
    static const coid::token b =
"client2.test_ffi = ffi.cast(\"client2_test0_fun\",client2.test);\n"\
"function client2:test()\n"\
"   return client2.test_ffi(self.__cthis)\n"\
"end;\n";
    body = b;
}
/*
void client2_lua_dispatcher::lua_test0_ffi(void * ifc_this){

}
*/
////////////////////////////////////////////////////////////////////////////////
//
//  coref<component_ifc> xt::client2::get()
//
__declspec(noinline) int client2_lua_dispatcher::lua_get1_exc(lua_State * L)
{
    bool exception_caught = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < 0 || args_count > 0) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "client2.get";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "client2.get";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<xt::client2>* ifc = reinterpret_cast<::lua::interface_wrapper_base<xt::client2>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "client2.get";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in


        //out params

        // invoke
        coref<component_ifc> rval__ = R_->get();

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream out
        to_lua(rval__);

        return 1;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int client2_lua_dispatcher::lua_get1(lua_State * L){
    int res = lua_get1_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool client2_lua_dispatcher::can_use_ffi_get1(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void client2_lua_dispatcher::get_ffi_inject_get1(coid::token& header, coid::token& body){
    static const coid::token h = "typedef coref<component_ifc> (*client2_get1_fun)(void * ifc_this)\n";
    header = h;
    static const coid::token b =
"client2.get_ffi = ffi.cast(\"client2_get1_fun\",client2.get);\n"\
"function client2:get()\n"\
"   return client2.get_ffi(self.__cthis)\n"\
"end;\n";
    body = b;
}
/*
coref<component_ifc> client2_lua_dispatcher::lua_get1_ffi(void * ifc_this){

}
*/


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int client2_lua_dispatcher::luarebind_events_exc(lua_State * L)
{
    return 0;
}

int client2_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////

bool client2_lua_dispatcher::contains_interface_class_table_internal(lua_State * L, bool push_on_top)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    int num_pops = 0;
    constexpr int num_namespaces = 1;
    if (num_pops == 0 && lua_hasfield(L, -1, "xt"))
    {
        lua_getfield(L, -1, "xt");
        num_pops++;
    }

    bool result = (num_pops == num_namespaces) && lua_hasfield(L, -1, "client2");

    if (push_on_top && result)
    {
        lua_getfield(L, -1, "client2");
        lua_insert(L, -1 - num_namespaces);
    }

    lua_pop(L, num_pops);

    DASSERT((result&& push_on_top) ? (stack_top + 1 == lua_gettop(L)) : (stack_top == lua_gettop(L)));

    return result;
}

////////////////////////////////////////////////////////////////////////////////

void client2_lua_dispatcher::get_interface_class_table_internal(lua_State* L)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    DASSERT(contains_interface_class_table_internal(L, false));

    constexpr int num_namespaces = 1;
    lua_getfield(L, -1, "xt");

    lua_getfield(L, -1, "client2");
    lua_insert(L, -1 - num_namespaces);
    lua_pop(L, num_namespaces);

    DASSERT(stack_top + 1 == lua_gettop(L));
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> client2_lua_dispatcher::create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var)
{
    lua_State * L = context->get_state();

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    context->push_ref();

    if(!is_bind_var)
    {
        // get object table
        lua_createtable(L, 0, 3);
    }
    else
    {
        if (!lua_hasfield(L, -1, script_class_or_bind_var))
        {
            lua_pop(L, 1); // pop context table
            coid::exception e("");
            e << "Given contex doesn't contain object binding variable with name " << script_class_or_bind_var << "!";
            throw e;
        }

        // get object table
        lua_getfield(L, -1, script_class_or_bind_var);
    }

    // get metatable
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_dispatcher_cptr_key);

    cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this->intergen_real_interface());
    lua_setfield(L, -2, ::lua::_lua_interface_cptr_key);

    lua_pushnumber(L, ints(4204168205));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);


    if (0)
    {
        ::lua::debug_print_stack(L);
    }

    // set index table
    if (!is_bind_var && !script_class_or_bind_var.is_empty())
    {
        if (!lua_hasfield(L, -2, script_class_or_bind_var))
        {
            lua_pop(L, 2); // pop context and object table
            coid::exception e("");
            e << "Given contex doesn't contain script class with name " << script_class_or_bind_var << "!";
            throw e;
        }

        lua_getfield(L, -2, script_class_or_bind_var);
    }
    else
    {
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
        if (!contains_interface_class_table_internal(L, true))
        {
            register_interface_client2(L, true);
        }

        lua_remove(L, -2); // remove interface metatable register table
    }
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_dispatcher_cptr_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_METATABLE_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();

    lua_pop(L, 1); // pop context table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(stack_top == current_stack_top);
    }
#endif

    _object = obj;
    set_context(context);
    return obj;
}



// --- registrar ---
int client2_lua_dispatcher::register_interface_client2(lua_State * L, bool push) {
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table

    lua_createtable(L, 0, 0); // table for namespace xt
    lua_pushvalue(L, -1);
    lua_setfield(L, -3, "xt");
    lua_remove(L, -2); // remove parent table from a stack

    lua_createtable(L, 0, 0);

    lua_pushcfunction(L, &client2_lua_dispatcher::lua_test0);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "test");

    lua_pushcfunction(L, &client2_lua_dispatcher::lua_get1);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "get");

    if (push)
    {
        lua_pushvalue(L, -1);
        lua_insert(L, -3);
    }

    lua_setfield(L, -2, "client2");
    lua_pop(L, 1); // pop namespace or interface metatable register table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == (push ? stack_top + 1 : stack_top)); // ensure we left the stack in the initial state
    }
#endif

    return 0;
}

int client2_lua_dispatcher::register_implementation_client2(lua_State * L, const coid::token& implementation_script_class_name)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context

    if(implementation_script_class_name.is_empty())
    {
        lua_createtable(L, 0, 0); // table for namespace xt
        lua_pushvalue(L, -1);
        lua_setfield(L, -3, "xt");
        lua_remove(L, -2); // remove parent table from a stack
    }

    lua_createtable(L, 0, 0); // table for class
    lua_pushvalue(L, -1); // get metatable
    lua_setmetatable(L, -2); // it is its own metatable

    // new we set __index table to aquire methods for c interface
    lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    if (!contains_interface_class_table_internal(L, true))
    {
        register_interface_client2(L, true);
    }

    lua_remove(L, -2); // remove interface metatable register table
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    lua_setfield(L, -2, implementation_script_class_name.is_empty()? "client2" : implementation_script_class_name);
    lua_pop(L, 1); // pop namespace or script context table

#ifdef _DEBUG
    DASSERT(lua_gettop(L) == stack_top); // ensure we left the stack in the initial state
#endif

    if (0)
    {
        lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context
        lua_hasfield(L, -1, "a.b.parent_class_ifc");
        ::lua::debug_print_stack(L);
    }

    return 0;
}


// --- creators ---

////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_client2(::xt::client2* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<xt::lua::client2_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::backend::lua)
        obj = static_cast<client2_lua_dispatcher*>(orig)->_object;

    if (obj.is_empty()) {
        // create interface object
        ifc.create(new xt::lua::client2_lua_dispatcher(context, static_cast<::xt::client2*>(orig)));

        obj = ifc->create_interface_object(context, true, "", false);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA interface from a host
static iref<xt::lua::client2_lua_dispatcher> create_maker_client2(policy_intrusive_base* host, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    iref<xt::lua::client2_lua_dispatcher> ifc;

    ifc.create(new xt::lua::client2_lua_dispatcher(host));
    ifc->create_interface_object(context, false, "", false);

    return ifc;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_client2(bool on)
{
    // implement in context function
    interface_register::register_interface_creator("lua::implement_class.xt.client2", on ? (void*)&client2_lua_dispatcher::register_implementation_client2 : nullptr, nullptr);


    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator("xt::client2@wrapper.lua", on ? (void*)&create_wrapper_client2 : nullptr, nullptr);

    //js interface creator from host
    interface_register::register_interface_creator("xt::client2@maker.lua", on ? (void*)&create_maker_client2 : nullptr, nullptr);
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) client2_autoregger = new ifc_autoregger(&register_binders_for_client2);

void* force_register_client2() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_client2);
    return autoregger.get();
}

} //namespace lua
} //namespace xt

