
//@file  interface dispatcher generated by intergen v9
//See LICENSE file for copyright and license information

#include "ifc/basei.h"
#include "ifc/emptyface.h"
#include "ifc/basething.h"
#include "ifc/thingface.h"
#include "ifc/ifc_int.h"
#include "ifc/ifc_ext.h"
#include "ifc/ifc_ext2.h"
#include "test.hpp"

#include <comm/ref.h>
#include <comm/global.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>

static_assert(intergen_interface::VERSION == 9, "interface must be rebuilt with a different intergen version");

using namespace coid;

static_assert(std::is_base_of<policy_intrusive_base, ::n1::n2::virtual_thing>::value, "class 'n1::n2::virtual_thing' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface basei of class n1::n2::virtual_thing


///
class basei_dispatcher : public basei
{
    friend class basei;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::method* creators = nullptr;
    inline static const meta::method methods[] = {
        { "xooo", meta::method::flg(0), 0, 0, 0, nullptr },
    };
    inline static const meta::method* events = nullptr;
    inline static const meta::class_interface ifc_meta = {
        "basei", // interface name
        "basei.h", // header file
        "", // storage
        "", // base class name
        3087611331, //version
        0, 1, 0, // num. creators/methods/events
        creators, methods, events,
        -1, -1, -1, -1,
        bvirtual,
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    static ifn_t* get_vtable()
    {
        return 0;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        return 0;
    }


protected:

    COIDNEWDELETE(basei_dispatcher);

    basei_dispatcher() {
    }

    virtual ~basei_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in basei capture dispatcher");
        }
    }

public:

    // creator methods

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);
    }
};


bool basei::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<basei>* pout)
{
    _host = host__;
    _vtable = basei_dispatcher::get_vtable();
    return true;
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) basei_autoregger = new ifc_autoregger(&basei_dispatcher::register_interfaces);

void* force_register_basei() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&basei_dispatcher::register_interfaces);
    return autoregger.get();
}


static_assert(std::is_base_of<policy_intrusive_base, ::n1::n2::empty_thing>::value, "class 'n1::n2::empty_thing' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface ifc1::ifc2::emptyface of class n1::n2::empty_thing

namespace ifc1 {
namespace ifc2 {

///
class emptyface_dispatcher : public emptyface
{
    friend class emptyface;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg get_0args[] = {
       { "return", "iref<n1::n2::empty_thing>", "iref<n1::n2::empty_thing>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, true, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg get2_1args[] = {
       { "return", "iref<n1::n2::empty_thing>", "iref<n1::n2::empty_thing>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, true, false, true, false, false, false, false, "" },
       { "p", "void*", "void", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method creators[] = {
        { "get", bstatic|biref|binternal|bnoevbody, 0, 0, 0, nullptr },
        { "get2", bstatic|biref|binternal|bnoevbody, 1, 1, 0, get2_1args },
    };
    inline static const meta::method* methods = nullptr;
    inline static const meta::method* events = nullptr;
    inline static const meta::class_interface ifc_meta = {
        "ifc1::ifc2::emptyface", // interface name
        "emptyface.h", // header file
        "iref<n1::n2::empty_thing>", // storage
        "", // base class name
        90057343, //version
        2, 0, 0, // num. creators/methods/events
        creators, methods, events,
        -1, 0, -1, -1,
        meta::class_interface::flg(0),
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[0];
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[0];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(emptyface_dispatcher);

    emptyface_dispatcher() {
    }

    virtual ~emptyface_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in emptyface capture dispatcher");
        }
    }

    static iref<emptyface> _host_connector(::n1::n2::empty_thing* host, emptyface* __here__)
    {
        iref<emptyface> rval;
        //a passive interface (no events)
        emptyface_dispatcher* dispatcher = __here__
            ? static_cast<emptyface_dispatcher*>(__here__)
            : new emptyface_dispatcher;
        rval.create(dispatcher);

        dispatcher->set_host(host, 0, 0);

        return rval;
    }

public:

    // creator methods

    static iref<emptyface> get(emptyface* here__)
    {
        iref<::n1::n2::empty_thing> host__ = ::n1::n2::empty_thing::_get_thing();
        if (!host__)
            return 0;
        return _host_connector(host__.get(), here__);
    }

    static iref<emptyface> get2(emptyface* here__, void* p)
    {
        iref<::n1::n2::empty_thing> host__ = ::n1::n2::empty_thing::_get2(p);
        if (!host__)
            return 0;
        return _host_connector(host__.get(), here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ifc1::ifc2::emptyface@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
        interface_register::register_interface_creator("ifc1::ifc2::emptyface.get@90057343", on ? (void*)&get : nullptr, &ifc_meta);
        interface_register::register_interface_creator("ifc1::ifc2::emptyface.get2@90057343", on ? (void*)&get2 : nullptr, &ifc_meta);
    }
};


bool emptyface::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<emptyface>* pout)
{
    _host = host__;
    _vtable = emptyface_dispatcher::get_vtable();
    return true;
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) emptyface_autoregger = new ifc_autoregger(&emptyface_dispatcher::register_interfaces);

void* force_register_emptyface() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&emptyface_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ifc1
} //namespace ifc2

static_assert(std::is_base_of<policy_intrusive_base, ::n1::n2::base_thing>::value, "class 'n1::n2::base_thing' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface ifc::basething of class n1::n2::base_thing

namespace ifc {

///
class basething_dispatcher : public basething
{
    friend class basething;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::method* creators = nullptr;
    inline static const meta::method methods[] = {
        { "xooo", meta::method::flg(0), 0, 0, 0, nullptr },
    };
    inline static const meta::method* events = nullptr;
    inline static const meta::class_interface ifc_meta = {
        "ifc::basething", // interface name
        "basething.h", // header file
        "", // storage
        "basei", // base class name
        3087611331, //version
        0, 1, 0, // num. creators/methods/events
        creators, methods, events,
        -1, -1, -1, -1,
        meta::class_interface::flg(0),
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[1];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::base_thing::xooo));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[1];
        _vtable2[0] = vtable1[0];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(basething_dispatcher);

    basething_dispatcher() {
    }

    virtual ~basething_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in basething capture dispatcher");
        }
    }

    static iref<basething> _host_connector(::n1::n2::base_thing* host, basething* __here__)
    {
        iref<basething> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            basething_dispatcher* dispatcher = __here__
                ? static_cast<basething_dispatcher*>(__here__)
                : new basething_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ifc::basething@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
    }
};


iref<basething> basething::intergen_active_interface(::n1::n2::base_thing* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<basething> rval;
    rval.add_refcount(static_cast<basething*>(host->_ifc.get()));

    return rval;
}

bool basething::assign_safe(intergen_interface* client__, iref<basething>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::base_thing* hostptr = host<::n1::n2::base_thing>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<basething*>(ifcvar.get()));

    return succ;
}

bool basething::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<basething>* pout)
{
    _host = host__;
    _vtable = basething_dispatcher::get_vtable();

    return assign_safe(client__, pout);
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) basething_autoregger = new ifc_autoregger(&basething_dispatcher::register_interfaces);

void* force_register_basething() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&basething_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ifc

static_assert(std::is_base_of<policy_intrusive_base, ::n1::n2::thing>::value, "class 'n1::n2::thing' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface ifc1::ifc2::thingface of class n1::n2::thing

namespace ifc1 {
namespace ifc2 {

///
class thingface_dispatcher : public thingface
{
    friend class thingface;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg get_2args[] = {
       { "return", "iref<n1::n2::thing>", "iref<n1::n2::thing>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, true, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg hallo_3args[] = {
       { "return", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "a", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "some argument \" test escaping" },
       { "b", "const coid::token&", "coid::token", "", "", "", "", &meta::stream_op<coid::token>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
       { "c", "coid::charstr&", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, false, true, false, false, false, "" },
    };
    inline static const meta::arg noscript_5args[] = {
       { "return", "ref<test>", "ref<test>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg fallo_6args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "str", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_7args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_const_8args[] = {
       { "return", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_nonconst_9args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "value", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg inout_10args[] = {
       { "par", "test*&", "test*", "", "", "", "", &meta::stream_op<test*>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, true, false, false, false, "" },
    };
    inline static const meta::arg ret_classifc_11args[] = {
       { "return", "iref<ifc1::ifc2::emptyface>", "ifc1::ifc2::emptyface", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_class, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg ret_structifc_12args[] = {
       { "return", "coref<component_ifc>", "component_ifc", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_struct, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg nested_13args[] = {
       { "stuff", "const coid::dynarray<bt::base>&", "coid::dynarray<bt::base>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method creators[] = {
        { "get", bstatic|biref|bnoevbody, 0, 0, 0, nullptr },
    };
    inline static const meta::method methods[] = {
        { "xooo", meta::method::flg(0), 0, 0, 0, nullptr },
        { "destroy", bdestroy, 0, 0, 0, nullptr },
        { "hallo", bnoevbody, 3, 2, 1, hallo_3args },
        { "noargs", meta::method::flg(0), 0, 0, 0, nullptr },
        { "noscript", binternal|bnoevbody, 0, 0, 0, nullptr },
        { "fallo", bnoevbody, 2, 2, 0, fallo_6args },
        { "loo", meta::method::flg(0), 2, 2, 0, loo_7args },
        { "operator()", bconst|boperator|bnoevbody, 1, 1, 0, operator_const_8args },
        { "operator()", boperator, 2, 2, 0, operator_nonconst_9args },
        { "inout", bnoevbody, 1, 1, 1, inout_10args },
        { "ret_classifc", bnoevbody, 0, 0, 0, nullptr },
        { "ret_structifc", bnoevbody, 0, 0, 0, nullptr },
        { "nested", binternal, 1, 1, 0, nested_13args },
    };
    inline static const meta::arg boo_0args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "some", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg body_1args[] = {
       { "return", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg strbody_2args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method events[] = {
        { "boo", meta::method::flg(0), 2, 2, 0, boo_0args },
        { "body", meta::method::flg(0), 0, 0, 0, nullptr },
        { "strbody", meta::method::flg(0), 0, 0, 0, nullptr },
    };
    inline static const meta::class_interface ifc_meta = {
        "ifc1::ifc2::thingface", // interface name
        "thingface.h", // header file
        "iref<n1::n2::thing>", // storage
        "basething", // base class name
        2715180211, //version
        1, 13, 3, // num. creators/methods/events
        creators, methods, events,
        1, 2, 8, 9,
        meta::class_interface::flg(0),
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    iref<ifc1::ifc2::emptyface> wrap_ret_classifc() {
        using wrapper_fn = iref<ifc1::ifc2::emptyface>(*)(policy_intrusive_base*, ifc1::ifc2::emptyface*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_connector("ifc1::ifc2::emptyface");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_classifc(), 0)
            : iref<ifc1::ifc2::emptyface>();
    }
    coref<component_ifc> wrap_ret_structifc() {
        using wrapper_fn = coref<component_ifc>(*)(component*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_dcconnector("component_ifc");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_structifc())
            : coref<component_ifc>(nullptr);
    }

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[13];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::xooo));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::destroy));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)(int,const coid::token&,coid::charstr&)>(&::n1::n2::thing::hallo));
        _vtable1[3] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::noargs));
        _vtable1[4] = reinterpret_cast<ifn_t>(static_cast<ref<test>(policy_intrusive_base::*)()>(&::n1::n2::thing::noscript));
        _vtable1[5] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(bool,const char*)>(&::n1::n2::thing::fallo));
        _vtable1[6] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,int)>(&::n1::n2::thing::loo));
        _vtable1[7] = reinterpret_cast<ifn_t>(static_cast<double(policy_intrusive_base::*)(const char*)const>(&::n1::n2::thing::operator()));
        _vtable1[8] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const char*,double)>(&::n1::n2::thing::operator()));
        _vtable1[9] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(test*&)>(&::n1::n2::thing::inout));
        _vtable1[10] = reinterpret_cast<ifn_t>(static_cast<iref<ifc1::ifc2::emptyface>(policy_intrusive_base::*)()>(&wrap_ret_classifc));
        _vtable1[11] = reinterpret_cast<ifn_t>(static_cast<coref<component_ifc>(policy_intrusive_base::*)()>(&wrap_ret_structifc));
        _vtable1[12] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const coid::dynarray<bt::base>&)>(&::n1::n2::thing::nested));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[13];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        _vtable2[3] = vtable1[3];
        _vtable2[4] = vtable1[4];
        _vtable2[5] = vtable1[5];
        _vtable2[6] = vtable1[6];
        _vtable2[7] = vtable1[7];
        _vtable2[8] = vtable1[8];
        _vtable2[9] = vtable1[9];
        _vtable2[10] = vtable1[10];
        _vtable2[11] = vtable1[11];
        _vtable2[12] = vtable1[12];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(thingface_dispatcher);

    thingface_dispatcher() {
    }

    virtual ~thingface_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in thingface capture dispatcher");
        }
    }

    static iref<thingface> _host_connector(::n1::n2::thing* host, thingface* __here__)
    {
        iref<thingface> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            thingface_dispatcher* dispatcher = __here__
                ? static_cast<thingface_dispatcher*>(__here__)
                : new thingface_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    static iref<thingface> get(thingface* here__)
    {
        iref<::n1::n2::thing> host__ = ::n1::n2::thing::get_thing();
        if (!host__)
            return 0;
        return _host_connector(host__.get(), here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ifc1::ifc2::thingface@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
        interface_register::register_interface_creator("ifc1::ifc2::thingface.get@2715180211", on ? (void*)&get : nullptr, &ifc_meta);
    }
};


iref<thingface> thingface::intergen_active_interface(::n1::n2::thing* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<thingface> rval;
    rval.add_refcount(static_cast<thingface*>(host->_ifc.get()));

    return rval;
}

bool thingface::assign_safe(intergen_interface* client__, iref<thingface>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::thing* hostptr = host<::n1::n2::thing>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<thingface*>(ifcvar.get()));

    return succ;
}

bool thingface::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<thingface>* pout)
{
    _host = host__;
    _vtable = thingface_dispatcher::get_vtable();

    return assign_safe(client__, pout);
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) thingface_autoregger = new ifc_autoregger(&thingface_dispatcher::register_interfaces);

void* force_register_thingface() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&thingface_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ifc1
} //namespace ifc2

// events

namespace n1 {
namespace n2 {

void thing::boo( const char* key, int some )
{
    if (!_ifc)
        throw coid::exception("Client not connected! (boo)");
    else
        return _ifc->iface<ifc1::ifc2::thingface>()->boo(key, some);
}

const char* thing::body()
{
    if (!_ifc)
        { return "string"; }
    else
        return _ifc->iface<ifc1::ifc2::thingface>()->body();
}

coid::charstr thing::strbody()
{
    if (!_ifc)
        { return "value"; }
    else
        return _ifc->iface<ifc1::ifc2::thingface>()->strbody();
}

} //namespace n1
} //namespace n2

////////////////////////////////////////////////////////////////////////////////
// interface ns::ifc_int of class n1::n2::thing

namespace ns {

///
class ifc_int_dispatcher : public ifc_int
{
    friend class ifc_int;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg hallo_2args[] = {
       { "return", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "a", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "some argument \" test escaping" },
       { "b", "const coid::token&", "coid::token", "", "", "", "", &meta::stream_op<coid::token>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
       { "c", "coid::charstr&", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, false, true, false, false, false, "" },
    };
    inline static const meta::arg noscript_4args[] = {
       { "return", "ref<test>", "ref<test>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg fallo_5args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "str", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_6args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_const_7args[] = {
       { "return", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_nonconst_8args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "value", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg inout_9args[] = {
       { "par", "test*&", "test*", "", "", "", "", &meta::stream_op<test*>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, true, false, false, false, "" },
    };
    inline static const meta::arg ret_classifc_10args[] = {
       { "return", "iref<ifc1::ifc2::emptyface>", "ifc1::ifc2::emptyface", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_class, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg ret_structifc_11args[] = {
       { "return", "coref<component_ifc>", "component_ifc", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_struct, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg nested_12args[] = {
       { "stuff", "const coid::dynarray<bt::base>&", "coid::dynarray<bt::base>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method* creators = nullptr;
    inline static const meta::method methods[] = {
        { "xooo", binherit, 0, 0, 0, nullptr },
        { "destroy", bdestroy|binherit, 0, 0, 0, nullptr },
        { "hallo", bnoevbody|binherit, 3, 2, 1, hallo_2args },
        { "noargs", binherit, 0, 0, 0, nullptr },
        { "noscript", binternal|bnoevbody|binherit, 0, 0, 0, nullptr },
        { "fallo", bnoevbody|binherit, 2, 2, 0, fallo_5args },
        { "loo", binherit, 2, 2, 0, loo_6args },
        { "operator()", bconst|boperator|bnoevbody|binherit, 1, 1, 0, operator_const_7args },
        { "operator()", boperator|binherit, 2, 2, 0, operator_nonconst_8args },
        { "inout", bnoevbody|binherit, 1, 1, 1, inout_9args },
        { "ret_classifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "ret_structifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "nested", binternal|binherit, 1, 1, 0, nested_12args },
        { "dummy", meta::method::flg(0), 0, 0, 0, nullptr },
    };
    inline static const meta::arg boo_0args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "some", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg body_1args[] = {
       { "return", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg strbody_2args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method events[] = {
        { "boo", binherit, 2, 2, 0, boo_0args },
        { "body", binherit, 0, 0, 0, nullptr },
        { "strbody", binherit, 0, 0, 0, nullptr },
    };
    inline static const meta::class_interface ifc_meta = {
        "ns::ifc_int", // interface name
        "ifc_int.h", // header file
        "", // storage
        "thingface", // base class name
        3357881492, //version
        0, 14, 3, // num. creators/methods/events
        creators, methods, events,
        1, -1, 7, 8,
        meta::class_interface::flg(0),
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    iref<ifc1::ifc2::emptyface> wrap_ret_classifc() {
        using wrapper_fn = iref<ifc1::ifc2::emptyface>(*)(policy_intrusive_base*, ifc1::ifc2::emptyface*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_connector("ifc1::ifc2::emptyface");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_classifc(), 0)
            : iref<ifc1::ifc2::emptyface>();
    }
    coref<component_ifc> wrap_ret_structifc() {
        using wrapper_fn = coref<component_ifc>(*)(component*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_dcconnector("component_ifc");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_structifc())
            : coref<component_ifc>(nullptr);
    }

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[14];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::xooo));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::destroy));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)(int,const coid::token&,coid::charstr&)>(&::n1::n2::thing::hallo));
        _vtable1[3] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::noargs));
        _vtable1[4] = reinterpret_cast<ifn_t>(static_cast<ref<test>(policy_intrusive_base::*)()>(&::n1::n2::thing::noscript));
        _vtable1[5] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(bool,const char*)>(&::n1::n2::thing::fallo));
        _vtable1[6] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,int)>(&::n1::n2::thing::loo));
        _vtable1[7] = reinterpret_cast<ifn_t>(static_cast<double(policy_intrusive_base::*)(const char*)const>(&::n1::n2::thing::operator()));
        _vtable1[8] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const char*,double)>(&::n1::n2::thing::operator()));
        _vtable1[9] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(test*&)>(&::n1::n2::thing::inout));
        _vtable1[10] = reinterpret_cast<ifn_t>(static_cast<iref<ifc1::ifc2::emptyface>(policy_intrusive_base::*)()>(&wrap_ret_classifc));
        _vtable1[11] = reinterpret_cast<ifn_t>(static_cast<coref<component_ifc>(policy_intrusive_base::*)()>(&wrap_ret_structifc));
        _vtable1[12] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const coid::dynarray<bt::base>&)>(&::n1::n2::thing::nested));
        _vtable1[13] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::dummy));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[14];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        _vtable2[3] = vtable1[3];
        _vtable2[4] = vtable1[4];
        _vtable2[5] = vtable1[5];
        _vtable2[6] = vtable1[6];
        _vtable2[7] = vtable1[7];
        _vtable2[8] = vtable1[8];
        _vtable2[9] = vtable1[9];
        _vtable2[10] = vtable1[10];
        _vtable2[11] = vtable1[11];
        _vtable2[12] = vtable1[12];
        _vtable2[13] = vtable1[13];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(ifc_int_dispatcher);

    ifc_int_dispatcher() {
    }

    virtual ~ifc_int_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in ifc_int capture dispatcher");
        }
    }

    static iref<ifc_int> _host_connector(::n1::n2::thing* host, ifc_int* __here__)
    {
        iref<ifc_int> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            ifc_int_dispatcher* dispatcher = __here__
                ? static_cast<ifc_int_dispatcher*>(__here__)
                : new ifc_int_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ns::ifc_int@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
    }
};


iref<ifc_int> ifc_int::intergen_active_interface(::n1::n2::thing* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<ifc_int> rval;
    rval.add_refcount(static_cast<ifc_int*>(host->_ifc.get()));

    return rval;
}

bool ifc_int::assign_safe(intergen_interface* client__, iref<ifc_int>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::thing* hostptr = host<::n1::n2::thing>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<ifc_int*>(ifcvar.get()));

    return succ;
}

bool ifc_int::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<ifc_int>* pout)
{
    _host = host__;
    _vtable = ifc_int_dispatcher::get_vtable();

    return assign_safe(client__, pout);
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) ifc_int_autoregger = new ifc_autoregger(&ifc_int_dispatcher::register_interfaces);

void* force_register_ifc_int() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&ifc_int_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ns

// events

namespace n1 {
namespace n2 {

} //namespace n1
} //namespace n2

static_assert(std::is_base_of<policy_intrusive_base, ::n1::n2::inherit_external>::value, "class 'n1::n2::inherit_external' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface ns::ifc_ext of class n1::n2::inherit_external

namespace ns {

///
class ifc_ext_dispatcher : public ifc_ext
{
    friend class ifc_ext;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg hallo_2args[] = {
       { "return", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "a", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "some argument \" test escaping" },
       { "b", "const coid::token&", "coid::token", "", "", "", "", &meta::stream_op<coid::token>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
       { "c", "coid::charstr&", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, false, true, false, false, false, "" },
    };
    inline static const meta::arg noscript_4args[] = {
       { "return", "ref<test>", "ref<test>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg fallo_5args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "str", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_6args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_const_7args[] = {
       { "return", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_nonconst_8args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "value", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg inout_9args[] = {
       { "par", "test*&", "test*", "", "", "", "", &meta::stream_op<test*>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, true, false, false, false, "" },
    };
    inline static const meta::arg ret_classifc_10args[] = {
       { "return", "iref<ifc1::ifc2::emptyface>", "ifc1::ifc2::emptyface", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_class, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg ret_structifc_11args[] = {
       { "return", "coref<component_ifc>", "component_ifc", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_struct, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg nested_12args[] = {
       { "stuff", "const coid::dynarray<bt::base>&", "coid::dynarray<bt::base>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_14args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method* creators = nullptr;
    inline static const meta::method methods[] = {
        { "xooo", binherit, 0, 0, 0, nullptr },
        { "destroy", bdestroy|binherit, 0, 0, 0, nullptr },
        { "hallo", bnoevbody|binherit, 3, 2, 1, hallo_2args },
        { "noargs", binherit, 0, 0, 0, nullptr },
        { "noscript", binternal|bnoevbody|binherit, 0, 0, 0, nullptr },
        { "fallo", bnoevbody|binherit, 2, 2, 0, fallo_5args },
        { "loo", binherit, 2, 2, 0, loo_6args },
        { "operator()", bconst|boperator|bnoevbody|binherit, 1, 1, 0, operator_const_7args },
        { "operator()", boperator|binherit, 2, 2, 0, operator_nonconst_8args },
        { "inout", bnoevbody|binherit, 1, 1, 1, inout_9args },
        { "ret_classifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "ret_structifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "nested", binternal|binherit, 1, 1, 0, nested_12args },
        { "mummy", meta::method::flg(0), 0, 0, 0, nullptr },
        { "loo", meta::method::flg(0), 2, 2, 0, loo_14args },
    };
    inline static const meta::arg boo_0args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "some", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg body_1args[] = {
       { "return", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg strbody_2args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method events[] = {
        { "boo", binherit, 2, 2, 0, boo_0args },
        { "body", binherit, 0, 0, 0, nullptr },
        { "strbody", binherit, 0, 0, 0, nullptr },
    };
    inline static const meta::class_interface ifc_meta = {
        "ns::ifc_ext", // interface name
        "ifc_ext.h", // header file
        "", // storage
        "thingface", // base class name
        3499303461, //version
        0, 15, 3, // num. creators/methods/events
        creators, methods, events,
        1, -1, 7, 8,
        meta::class_interface::flg(0),
        R"##()##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    iref<ifc1::ifc2::emptyface> wrap_ret_classifc() {
        using wrapper_fn = iref<ifc1::ifc2::emptyface>(*)(policy_intrusive_base*, ifc1::ifc2::emptyface*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_connector("ifc1::ifc2::emptyface");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_classifc(), 0)
            : iref<ifc1::ifc2::emptyface>();
    }
    coref<component_ifc> wrap_ret_structifc() {
        using wrapper_fn = coref<component_ifc>(*)(component*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_dcconnector("component_ifc");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_structifc())
            : coref<component_ifc>(nullptr);
    }

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[15];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::xooo));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::destroy));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)(int,const coid::token&,coid::charstr&)>(&::n1::n2::thing::hallo));
        _vtable1[3] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::noargs));
        _vtable1[4] = reinterpret_cast<ifn_t>(static_cast<ref<test>(policy_intrusive_base::*)()>(&::n1::n2::thing::noscript));
        _vtable1[5] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(bool,const char*)>(&::n1::n2::thing::fallo));
        _vtable1[6] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,int)>(&::n1::n2::thing::loo));
        _vtable1[7] = reinterpret_cast<ifn_t>(static_cast<double(policy_intrusive_base::*)(const char*)const>(&::n1::n2::thing::operator()));
        _vtable1[8] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const char*,double)>(&::n1::n2::thing::operator()));
        _vtable1[9] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(test*&)>(&::n1::n2::thing::inout));
        _vtable1[10] = reinterpret_cast<ifn_t>(static_cast<iref<ifc1::ifc2::emptyface>(policy_intrusive_base::*)()>(&wrap_ret_classifc));
        _vtable1[11] = reinterpret_cast<ifn_t>(static_cast<coref<component_ifc>(policy_intrusive_base::*)()>(&wrap_ret_structifc));
        _vtable1[12] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const coid::dynarray<bt::base>&)>(&::n1::n2::thing::nested));
        _vtable1[13] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::inherit_external::mummy));
        _vtable1[14] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,bool)>(&::n1::n2::inherit_external::loo));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[15];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        _vtable2[3] = vtable1[3];
        _vtable2[4] = vtable1[4];
        _vtable2[5] = vtable1[5];
        _vtable2[6] = vtable1[6];
        _vtable2[7] = vtable1[7];
        _vtable2[8] = vtable1[8];
        _vtable2[9] = vtable1[9];
        _vtable2[10] = vtable1[10];
        _vtable2[11] = vtable1[11];
        _vtable2[12] = vtable1[12];
        _vtable2[13] = vtable1[13];
        _vtable2[14] = vtable1[14];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(ifc_ext_dispatcher);

    ifc_ext_dispatcher() {
    }

    virtual ~ifc_ext_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in ifc_ext capture dispatcher");
        }
    }

    static iref<ifc_ext> _host_connector(::n1::n2::inherit_external* host, ifc_ext* __here__)
    {
        iref<ifc_ext> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            ifc_ext_dispatcher* dispatcher = __here__
                ? static_cast<ifc_ext_dispatcher*>(__here__)
                : new ifc_ext_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ns::ifc_ext@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
    }
};


iref<ifc_ext> ifc_ext::intergen_active_interface(::n1::n2::inherit_external* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<ifc_ext> rval;
    rval.add_refcount(static_cast<ifc_ext*>(host->_ifc.get()));

    return rval;
}

bool ifc_ext::assign_safe(intergen_interface* client__, iref<ifc_ext>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::inherit_external* hostptr = host<::n1::n2::inherit_external>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<ifc_ext*>(ifcvar.get()));

    return succ;
}

bool ifc_ext::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<ifc_ext>* pout)
{
    _host = host__;
    _vtable = ifc_ext_dispatcher::get_vtable();

    return assign_safe(client__, pout);
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) ifc_ext_autoregger = new ifc_autoregger(&ifc_ext_dispatcher::register_interfaces);

void* force_register_ifc_ext() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&ifc_ext_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ns

// events

namespace n1 {
namespace n2 {

} //namespace n1
} //namespace n2

////////////////////////////////////////////////////////////////////////////////
// interface ns::ifc_ext2 of class n1::n2::inherit_external

namespace ns {

///
class ifc_ext2_dispatcher : public ifc_ext2
{
    friend class ifc_ext2;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg hallo_2args[] = {
       { "return", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "a", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "some argument \" test escaping" },
       { "b", "const coid::token&", "coid::token", "", "", "", "", &meta::stream_op<coid::token>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
       { "c", "coid::charstr&", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, false, true, false, false, false, "" },
    };
    inline static const meta::arg noscript_4args[] = {
       { "return", "ref<test>", "ref<test>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg fallo_5args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "str", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_6args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_const_7args[] = {
       { "return", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg operator_nonconst_8args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "value", "double", "double", "", "", "", "", &meta::stream_op<double>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg inout_9args[] = {
       { "par", "test*&", "test*", "", "", "", "", &meta::stream_op<test*>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, true, false, false, false, "" },
    };
    inline static const meta::arg ret_classifc_10args[] = {
       { "return", "iref<ifc1::ifc2::emptyface>", "ifc1::ifc2::emptyface", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_class, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg ret_structifc_11args[] = {
       { "return", "coref<component_ifc>", "component_ifc", "", "", "", "", nullptr, meta::arg::ifc_type::ifc_struct, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg nested_12args[] = {
       { "stuff", "const coid::dynarray<bt::base>&", "coid::dynarray<bt::base>", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg loo_14args[] = {
       { "a", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
       { "b", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method* creators = nullptr;
    inline static const meta::method methods[] = {
        { "xooo", binherit, 0, 0, 0, nullptr },
        { "destroy", bdestroy|binherit, 0, 0, 0, nullptr },
        { "hallo", bnoevbody|binherit, 3, 2, 1, hallo_2args },
        { "noargs", binherit, 0, 0, 0, nullptr },
        { "noscript", binternal|bnoevbody|binherit, 0, 0, 0, nullptr },
        { "fallo", bnoevbody|binherit, 2, 2, 0, fallo_5args },
        { "loo", binherit, 2, 2, 0, loo_6args },
        { "operator()", bconst|boperator|bnoevbody|binherit, 1, 1, 0, operator_const_7args },
        { "operator()", boperator|binherit, 2, 2, 0, operator_nonconst_8args },
        { "inout", bnoevbody|binherit, 1, 1, 1, inout_9args },
        { "ret_classifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "ret_structifc", bnoevbody|binherit, 0, 0, 0, nullptr },
        { "nested", binternal|binherit, 1, 1, 0, nested_12args },
        { "mummy", binherit, 0, 0, 0, nullptr },
        { "loo", meta::method::flg(0), 2, 2, 0, loo_14args },
        { "some1", meta::method::flg(0), 0, 0, 0, nullptr },
        { "some2", meta::method::flg(0), 0, 0, 0, nullptr },
    };
    inline static const meta::arg boo_0args[] = {
       { "key", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
       { "some", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg body_1args[] = {
       { "return", "const char*", "const char*", "", "", "", "", nullptr, meta::arg::ifc_type::none, true, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg strbody_2args[] = {
       { "return", "coid::charstr", "coid::charstr", "", "", "", "", &meta::stream_op<coid::charstr>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg noo_3args[] = {
       { "return", "bool", "bool", "", "", "", "", &meta::stream_op<bool>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::method events[] = {
        { "boo", binherit, 2, 2, 0, boo_0args },
        { "body", binherit, 0, 0, 0, nullptr },
        { "strbody", binherit, 0, 0, 0, nullptr },
        { "noo", bnoevbody, 0, 0, 0, nullptr },
    };
    inline static const meta::class_interface ifc_meta = {
        "ns::ifc_ext2", // interface name
        "ifc_ext2.h", // header file
        "", // storage
        "ifc_ext", // base class name
        2054706178, //version
        0, 17, 4, // num. creators/methods/events
        creators, methods, events,
        1, -1, 7, 8,
        meta::class_interface::flg(0),
        R"##(////
)##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    iref<ifc1::ifc2::emptyface> wrap_ret_classifc() {
        using wrapper_fn = iref<ifc1::ifc2::emptyface>(*)(policy_intrusive_base*, ifc1::ifc2::emptyface*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_connector("ifc1::ifc2::emptyface");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_classifc(), 0)
            : iref<ifc1::ifc2::emptyface>();
    }
    coref<component_ifc> wrap_ret_structifc() {
        using wrapper_fn = coref<component_ifc>(*)(component*);
        static wrapper_fn wrapper = (wrapper_fn)interface_register::get_interface_dcconnector("component_ifc");
        return wrapper
            ? wrapper(_host.cast<::n1::n2::thing>()->ret_structifc())
            : coref<component_ifc>(nullptr);
    }

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[17];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::xooo));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::destroy));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)(int,const coid::token&,coid::charstr&)>(&::n1::n2::thing::hallo));
        _vtable1[3] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::noargs));
        _vtable1[4] = reinterpret_cast<ifn_t>(static_cast<ref<test>(policy_intrusive_base::*)()>(&::n1::n2::thing::noscript));
        _vtable1[5] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(bool,const char*)>(&::n1::n2::thing::fallo));
        _vtable1[6] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,int)>(&::n1::n2::thing::loo));
        _vtable1[7] = reinterpret_cast<ifn_t>(static_cast<double(policy_intrusive_base::*)(const char*)const>(&::n1::n2::thing::operator()));
        _vtable1[8] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const char*,double)>(&::n1::n2::thing::operator()));
        _vtable1[9] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(test*&)>(&::n1::n2::thing::inout));
        _vtable1[10] = reinterpret_cast<ifn_t>(static_cast<iref<ifc1::ifc2::emptyface>(policy_intrusive_base::*)()>(&wrap_ret_classifc));
        _vtable1[11] = reinterpret_cast<ifn_t>(static_cast<coref<component_ifc>(policy_intrusive_base::*)()>(&wrap_ret_structifc));
        _vtable1[12] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(const coid::dynarray<bt::base>&)>(&::n1::n2::thing::nested));
        _vtable1[13] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::inherit_external::mummy));
        _vtable1[14] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)(bool,bool)>(&::n1::n2::inherit_external::loo2));
        _vtable1[15] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::inherit_external::some1));
        _vtable1[16] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::inherit_external::some2));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[17];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        _vtable2[3] = vtable1[3];
        _vtable2[4] = vtable1[4];
        _vtable2[5] = vtable1[5];
        _vtable2[6] = vtable1[6];
        _vtable2[7] = vtable1[7];
        _vtable2[8] = vtable1[8];
        _vtable2[9] = vtable1[9];
        _vtable2[10] = vtable1[10];
        _vtable2[11] = vtable1[11];
        _vtable2[12] = vtable1[12];
        _vtable2[13] = vtable1[13];
        _vtable2[14] = vtable1[14];
        _vtable2[15] = vtable1[15];
        _vtable2[16] = vtable1[16];
        return _vtable2;
    }


protected:

    COIDNEWDELETE(ifc_ext2_dispatcher);

    ifc_ext2_dispatcher() {
    }

    virtual ~ifc_ext2_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in ifc_ext2 capture dispatcher");
        }
    }

    static iref<ifc_ext2> _host_connector(::n1::n2::inherit_external* host, ifc_ext2* __here__)
    {
        iref<ifc_ext2> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            ifc_ext2_dispatcher* dispatcher = __here__
                ? static_cast<ifc_ext2_dispatcher*>(__here__)
                : new ifc_ext2_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
        interface_register::register_interface(ifc_meta, &register_interfaces);

        interface_register::register_interface_creator("ns::ifc_ext2@connect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
    }
};


iref<ifc_ext2> ifc_ext2::intergen_active_interface(::n1::n2::inherit_external* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<ifc_ext2> rval;
    rval.add_refcount(static_cast<ifc_ext2*>(host->_ifc.get()));

    return rval;
}

bool ifc_ext2::assign_safe(intergen_interface* client__, iref<ifc_ext2>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::inherit_external* hostptr = host<::n1::n2::inherit_external>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<ifc_ext2*>(ifcvar.get()));

    return succ;
}

bool ifc_ext2::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<ifc_ext2>* pout)
{
    _host = host__;
    _vtable = ifc_ext2_dispatcher::get_vtable();

    return assign_safe(client__, pout);
}

//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) ifc_ext2_autoregger = new ifc_autoregger(&ifc_ext2_dispatcher::register_interfaces);

void* force_register_ifc_ext2() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&ifc_ext2_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ns

// events

namespace n1 {
namespace n2 {

bool inherit_external::noo()
{
    if (!_ifc)
        throw coid::exception("Client not connected! (noo)");
    else
        return _ifc->iface<ns::ifc_ext2>()->noo();
}

} //namespace n1
} //namespace n2

