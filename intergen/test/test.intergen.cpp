
//@file  interface dispatcher generated by intergen v7
//See LICENSE file for copyright and license information

#include "ifc/thingface.h"
#include "test.hpp"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == 7, "interface must be rebuilt with a different intergen version");

using namespace coid;

static_assert( std::is_base_of<policy_intrusive_base, ::n1::n2::thing>::value, "class 'thing' must be derived from policy_intrusive_base");

////////////////////////////////////////////////////////////////////////////////
// interface ifc1::ifc2::thingface of class thing

namespace ifc1 {
namespace ifc2 {

///
class thingface_dispatcher : public thingface
{
    friend class thingface;

private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[3];
        _vtable1[0] = reinterpret_cast<ifn_t>(static_cast<void(policy_intrusive_base::*)()>(&::n1::n2::thing::destroy));
        _vtable1[1] = reinterpret_cast<ifn_t>(static_cast<int(policy_intrusive_base::*)(int,const coid::token&,coid::charstr&)>(&::n1::n2::thing::hallo));
        _vtable1[2] = reinterpret_cast<ifn_t>(static_cast<coid::charstr(policy_intrusive_base::*)(bool,const char*)>(&::n1::n2::thing::fallo));
        return _vtable1;
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))


    static ifn_t* get_vtable_intercept()
    {
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[3];
        _vtable2[0] = vtable1[0];
        _vtable2[1] = vtable1[1];
        _vtable2[2] = vtable1[2];
        return _vtable2;
    }

protected:

    COIDNEWDELETE(thingface_dispatcher);

    thingface_dispatcher() {
    }

    virtual ~thingface_dispatcher() {
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        case UMAX32:
        default: throw coid::exception("unknown method id in thingface capture dispatcher");
        }
    }

    static iref<thingface> _generic_interface_creator(::n1::n2::thing* host, thingface* __here__)
    {
        iref<thingface> rval;
        //an active interface (with events)
        if (host->_ifc && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            thingface_dispatcher* dispatcher = __here__
                ? static_cast<thingface_dispatcher*>(__here__)
                : new thingface_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }

        return rval;
    }

public:

    // creator methods

    static iref<thingface> get( thingface* __here__ )
    {
        iref<::n1::n2::thing> __host__ = ::n1::n2::thing::get_thing();
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
        interface_register::register_interface_creator(
            "ifc1::ifc2::thingface@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

        interface_register::register_interface_creator(
            "ifc1::ifc2::thingface.get@1555033958",
            on ? (void*)&get : nullptr);
    }
};

coid::binstring* thingface_dispatcher::_capture = 0;
uint16 thingface_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* thingface_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* thingface_dispatcher::_vtable1 = 0;

iref<thingface> thingface::intergen_active_interface(::n1::n2::thing* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<thingface> rval;
    rval.add_refcount(static_cast<thingface*>(host->_ifc.get()));

    return rval;
}

bool thingface::assign_safe(intergen_interface* client, iref<thingface>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::n1::n2::thing* hostptr = host<::n1::n2::thing>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->_ifc;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client;
    if (succ) {
        ifcvar = client;
        _cleaner = client ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<thingface*>(ifcvar.get()));

    return succ;
}

bool thingface::set_host(policy_intrusive_base* host, intergen_interface* client, iref<thingface>* pout)
{
    _host = host;
    _vtable = thingface_dispatcher::get_vtable();

    return assign_safe(client, pout);
}

//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) thingface_autoregger = new ifc_autoregger(&thingface_dispatcher::register_interfaces);

void* force_register_thingface() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&thingface_dispatcher::register_interfaces);
    return autoregger.get();
}

} //namespace ifc1
} //namespace ifc2

// events

namespace n1 {
namespace n2 {

void thing::boo( const char* key )
{
    if (!_ifc) 
        throw coid::exception() << "boo" << " handler not implemented";
    else
        return _ifc->iface<ifc1::ifc2::thingface>()->boo(key);
}

} //namespace n1
} //namespace n2

